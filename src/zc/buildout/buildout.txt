Buildouts
=========

The word "buildout" refers to a description of a set of parts and the
software to create and assemble them.  It is often used informally to
refer to an installed system based on a buildout definition.  For
example, if we are creating an application named "Foo", then "the Foo
buildout" is the collection of configuration and application-specific
software that allows an instance of the application to be created.  We
may refer to such an instance of the application informally as "a Foo
buildout".

This document describes how to define buildouts using buildout
configuration files and recipes.  There are three ways to set up the
buildout software and create a buildout instance:

1. Install the zc.buildout egg with easy_install and use the buildout
   script installed in a Python scripts area.

2. Use the buildout bootstrap script to create a buildout that
   includes both the distribute and zc.buildout eggs.  This allows you
   to use the buildout software without modifying a Python install.
   The buildout script is installed into your buildout local scripts
   area.

3. Use a buildout command from an already installed buildout to
   bootstrap a new buildout.  (See the section on bootstraping later
   in this document.)

Often, a software project will be managed in a software repository,
such as a subversion repository, that includes some software source
directories, buildout configuration files, and a copy of the buildout
bootstrap script.  To work on the project, one would check out the
project from the repository and run the bootstrap script which
installs distribute and zc.buildout into the checkout as well as any
parts defined.

We have a sample buildout that we created using the bootstrap command
of an existing buildout (method 3 above).  It has the absolute minimum
information.  We have bin, develop-eggs, eggs and parts directories,
and a configuration file:

    >>> ls(sample_buildout)
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  parts

The bin directory contains scripts.

    >>> ls(sample_buildout, 'bin')
    -  buildout

    >>> ls(sample_buildout, 'eggs')
    -  distribute-0.6-py2.4.egg
    -  zc.buildout-1.0-py2.4.egg

The develop-eggs and parts directories are initially empty:

    >>> ls(sample_buildout, 'develop-eggs')
    >>> ls(sample_buildout, 'parts')

The develop-eggs directory holds egg links for software being
developed in the buildout.  We separate develop-eggs and other eggs to
allow eggs directories to be shared across multiple buildouts.  For
example, a common developer technique is to define a common eggs
directory in their home that all non-develop eggs are stored in.  This
allows larger buildouts to be set up much more quickly and saves disk
space.

The parts directory provides an area where recipes can install
part data.  For example, if we built a custom Python, we would
install it in the part directory.  Part data is stored in a
sub-directory of the parts directory with the same name as the part.

Buildouts are defined using configuration files.  These are in the
format defined by the Python ConfigParser module, with extensions
that we'll describe later.  By default, when a buildout is run, it
looks for the file buildout.cfg in the directory where the buildout is
run.

The minimal configuration file has a buildout section that defines no
parts:

    >>> cat(sample_buildout, 'buildout.cfg')
    [buildout]
    parts =

A part is simply something to be created by a buildout.  It can be
almost anything, such as a Python package, a program, a directory, or
even a configuration file.

Recipes
-------

A part is created by a recipe.  Recipes are always installed as Python
eggs. They can be downloaded from a package server, such as the
Python Package Index, or they can be developed as part of a project
using a "develop" egg.

A develop egg is a special kind of egg that gets installed as an "egg
link" that contains the name of a source directory.  Develop eggs
don't have to be packaged for distribution to be used and can be
modified in place, which is especially useful while they are being
developed.

Let's create a recipe as part of the sample project.  We'll create a
recipe for creating directories.  First, we'll create a recipes source
directory for our local recipes:

    >>> mkdir(sample_buildout, 'recipes')

and then we'll create a source file for our mkdir recipe:

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...         options['path'] = os.path.join(
    ...                               buildout['buildout']['directory'],
    ...                               options['path'],
    ...                               )
    ...         if not os.path.isdir(os.path.dirname(options['path'])):
    ...             logging.getLogger(self.name).error(
    ...                 'Cannot create %s. %s is not a directory.',
    ...                 options['path'], os.path.dirname(options['path']))
    ...             raise zc.buildout.UserError('Invalid Path')
    ...
    ...
    ...     def install(self):
    ...         path = self.options['path']
    ...         logging.getLogger(self.name).info(
    ...             'Creating directory %s', os.path.basename(path))
    ...         os.mkdir(path)
    ...         return path
    ...
    ...     def update(self):
    ...         pass
    ... """)

Currently, recipes must define 3 methods:

- a constructor,

- an install method, and

- an update method.

The constructor is responsible for updating a parts options to reflect
data read from other sections.  The buildout system keeps track of
whether a part specification has changed.  A part specification has
changed if it's options, after adjusting for data read from other
sections, has changed, or if the recipe has changed.  Only the options
for the part are considered.  If data are read from other sections,
then that information has to be reflected in the parts options.  In
the Mkdir example, the given path is interpreted relative to the
buildout directory, and data from the buildout directory is read.  The
path option is updated to reflect this.  If the directory option was
changed in the buildout sections, we would know to update parts
created using the mkdir recipe using relative path names.

When buildout is run, it saves configuration data for installed parts
in a file named ".installed.cfg".  In subsequent runs, it compares
part-configuration data stored in the .installed.cfg file and the
part-configuration data loaded from the configuration files as
modified by recipe constructors to decide if the configuration of a
part has changed. If the configuration has changed, or if the recipe
has changed, then the part is uninstalled and reinstalled.  The
buildout only looks at the part's options, so any data used to
configure the part needs to be reflected in the part's options.  It is
the job of a recipe constructor to make sure that the options include
all relevant data.

Of course, parts are also uninstalled if they are no-longer used.

The recipe defines a constructor that takes a buildout object, a part
name, and an options dictionary. It saves them in instance attributes.
If the path is relative, we'll interpret it as relative to the
buildout directory.  The buildout object passed in is a mapping from
section name to a mapping of options for that section. The buildout
directory is available as the directory option of the buildout
section.  We normalize the path and save it back into the options
directory.

The install method is responsible for creating the part.  In this
case, we need the path of the directory to create.  We'll use a path
option from our options dictionary.  The install method logs what it's
doing using the Python logging call.  We return the path that we
installed.  If the part is uninstalled or reinstalled, then the path
returned will be removed by the buildout machinery.  A recipe install
method is expected to return a string, or an iterable of strings
containing paths to be removed if a part is uninstalled.  For most
recipes, this is all of the uninstall support needed. For more complex
uninstallation scenarios use `Uninstall recipes`_.

The update method is responsible for updating an already installed
part.  An empty method is often provided, as in this example, if parts
can't be updated.  An update method can return None, a string, or an
iterable of strings.  If a string or iterable of strings is returned,
then the saved list of paths to be uninstalled is updated with the new
information by adding any new files returned by the update method.

We need to provide packaging information so that our recipe can be
installed as a develop egg. The minimum information we need to specify
is a name.  For recipes, we also need to define the
names of the recipe classes as entry points.  Packaging information is
provided via a setup.py script:

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name = "recipes",
    ...     entry_points = {'zc.buildout': ['mkdir = mkdir:Mkdir']},
    ...     )
    ... """)

Our setup script defines an entry point. Entry points provide
a way for an egg to define the services it provides.  Here we've said
that we define a zc.buildout entry point named mkdir.  Recipe
classes must be exposed as entry points in the zc.buildout group.  we
give entry points names within the group.

We also need a README.txt for our recipes to avoid an annoying warning
from distutils, on which distribute and zc.buildout are based:

    >>> write(sample_buildout, 'recipes', 'README.txt', " ")

Now let's update our buildout.cfg:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mystuff
    ... """)

Let's go through the changes one by one::

    develop = recipes

This tells the buildout to install a development egg for our recipes.
Any number of paths can be listed.  The paths can be relative or
absolute.  If relative, they are treated as relative to the buildout
directory.  They can be directory or file paths.  If a file path is
given, it should point to a Python setup script.  If a directory path
is given, it should point to a directory containing a setup.py file.
Development eggs are installed before building any parts, as they may
provide locally-defined recipes needed by the parts.

::

    parts = data-dir

Here we've named a part to be "built".  We can use any name we want
except that different part names must be unique and recipes will often
use the part name to decide what to do.

::

    [data-dir]
    recipe = recipes:mkdir
    path = mystuff


When we name a part, we also create a section of the same
name that contains part data.  In this section, we'll define
the recipe to be used to install the part.  In this case, we also
specify the path to be created.

Let's run the buildout.  We do so by running the build script in the
buildout:

    >>> import os
    >>> os.chdir(sample_buildout)
    >>> buildout = os.path.join(sample_buildout, 'bin', 'buildout')
    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory mystuff

We see that the recipe created the directory, as expected:

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  mystuff
    d  parts
    d  recipes

In addition, .installed.cfg has been created containing information
about the part we installed:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir
    <BLANKLINE>
    [data-dir]
    __buildout_installed__ = /sample-buildout/mystuff
    __buildout_signature__ = recipes-c7vHV6ekIDUPy/7fjAaYjg==
    path = /sample-buildout/mystuff
    recipe = recipes:mkdir

Note that the directory we installed is included in .installed.cfg.
In addition, the path option includes the actual destination
directory.

If we change the name of the directory in the configuration file,
we'll see that the directory gets removed and recreated:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  mydata
    d  parts
    d  recipes

If any of the files or directories created by a recipe are removed,
the part will be reinstalled:

    >>> rmdir(sample_buildout, 'mydata')
    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata

Error reporting
---------------

If a user makes an error, an error needs to be printed and work needs
to stop.  This is accomplished by logging a detailed error message and
then raising a (or an instance of a subclass of a)
zc.buildout.UserError exception.  Raising an error other than a
UserError still displays the error, but labels it as a bug in the
buildout software or recipe. In the sample above, of someone gives a
non-existent directory to create the directory in:


    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = /xxx/mydata
    ... """)

We'll get a user error, not a traceback.

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    data-dir: Cannot create /xxx/mydata. /xxx is not a directory.
    While:
      Installing.
      Getting section data-dir.
      Initializing part data-dir.
    Error: Invalid Path


Recipe Error Handling
---------------------

If an error occurs during installation, it is up to the recipe to
clean up any system side effects, such as files created.  Let's update
the mkdir recipe to support multiple paths:

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         for path in paths:
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...         return paths
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

If there is an error creating a path, the install method will exit and
leave previously created paths in place:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bin
    ... """)

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occured due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

We meant to create a directory bins, but typed bin.  Now foo was
left behind.

    >>> os.path.exists('foo')
    True

If we fix the typo:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bins
    ... """)

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occured due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

Now they fail because foo exists, because it was left behind.

    >>> remove('foo')

Let's fix the recipe:

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout, sys
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         created = []
    ...         try:
    ...             for path in paths:
    ...                 logging.getLogger(self.name).info(
    ...                     'Creating directory %s', os.path.basename(path))
    ...                 os.mkdir(path)
    ...                 created.append(path)
    ...         except Exception:
    ...             for d in created:
    ...                 os.rmdir(d)
    ...                 assert not os.path.exists(d)
    ...                 logging.getLogger(self.name).info(
    ...                     'Removed %s due to error',
    ...                      os.path.basename(d))
    ...             sys.stderr.flush()
    ...             sys.stdout.flush()
    ...             raise
    ...
    ...         return paths
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

And put back the typo:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bin
    ... """)

When we rerun the buildout:

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    data-dir: Removed foo due to error
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occured due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

we get the same error, but we don't get the directory left behind:

    >>> os.path.exists('foo')
    False

It's critical that recipes clean up partial effects when errors
occur.  Because recipes most commonly create files and directories,
buildout provides a helper API for removing created files when an
error occurs.  Option objects have a created method that can be called
to record files as they are created.  If the install or update method
returns with an error, then any registered paths are removed
automatically.  The method returns the files registered and can be
used to return the files created.  Let's use this API to simplify the
recipe:

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         for path in paths:
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...             self.options.created(path)
    ...
    ...         return self.options.created()
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

We returned by calling created, taking advantage of the fact that it
returns the registered paths.  We did this for illustrative purposes.
It would be simpler just to return the paths as before.

If we rerun the buildout, again, we'll get the error and no
directories will be created:

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occured due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

    >>> os.path.exists('foo')
    False

Now, we'll fix the typo again and we'll get the directories we expect:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bins
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bins

    >>> os.path.exists('foo')
    True
    >>> os.path.exists('bins')
    True

Configuration file syntax
-------------------------

A buildout configuration file consists of a sequence of sections.  A
section has a section header followed by 0 or more section options.
(Buildout configuration files may be viewed as a variation on INI
files.)

A section header consists of a section name enclosed in square braces.
A section name consists of one or more non-whitespace characters
other than square braces ('[', ']'), curly braces ('{', '}'), colons
(':') or equal signs ('='). Whitespace surrounding section names is ignored.

Options consist of option names, followed by optional space or tab
characters, an optional plus or minus sign and an equal signs and
values.  An option value may be spread over multiple lines as long as
the lines after the first start with a whitespace character.  An
option name consists of one or more non-whitespace characters other
than equal signs, square braces ("[", "]"), curly braces ("{", "}"),
plus signs or colons (":"). The option name '<' is reserved.  An
option's data consists of the characters following the equal sign on
the start line, plus the continuation lines.

Option values have extra whitespace stripped.  How this is done
depends on whether the value has non-whitespace characterts on the
first line.  If an option value has non-whitespace characters on the
first line, then each line is stripped and blank lines are removed.
For exampe, in::

  [foo]
  bar = 1
  baz = a
        b

        c

.. -> text

    >>> try: import StringIO
    ... except ImportError: import io as StringIO
    >>> import pprint, zc.buildout.configparser
    >>> pprint.pprint(zc.buildout.configparser.parse(StringIO.StringIO(
    ...     text), 'test'))
    {'foo': {'bar': '1', 'baz': 'a\nb\nc'}}

The value of of ``bar`` is ``'1'`` and the value of ``baz`` is
``'a\nb\nc'``.

If the first line of an option doesn't contain whitespace, then the
value is dedented (with ``textwrap.dedent``), trailing spaces in lines
are removed, and leading and trailing blank lines are removed.  For
example, in::


  [foo]
  bar =
  baz =

    a
      b

    c

.. -> text

    >>> pprint.pprint(zc.buildout.configparser.parse(StringIO.StringIO(
    ...     text), 'test'))
    {'foo': {'bar': '', 'baz': 'a\n  b\n\nc'}}

The value of bar is ``''``, and the value of baz is ``'a\n  b\n\nc'``.

Lines starting with '#' or ';' characters are comments.  Comments can
also be placed after the closing square bracket (']') in a section header.

Buildout configuration data are Python strings, which are bytes in
Python 2 and unicode in Python 3.

Sections and options within sections may be repeated.  Multiple
occurrences of of a section are treated as if they were concantinated.
The last option value for a given name in a section overrides previous
values.

In addition top the syntactic details above:

- option names are case sensitive

- option values can use a substitution syntax, described below, to
  refer to option values in specific sections.

- option values can be appended or removed using the - and +
  operators.

Annotated sections
------------------

When used with the `annotate` command, buildout displays annotated sections.
All sections are displayed, sorted alphabetically. For each section,
all key-value pairs are displayed, sorted alphabetically, along with
the origin of the value (file name or COMPUTED_VALUE, DEFAULT_VALUE,
COMMAND_LINE_VALUE).

    >>> print_(system(buildout+ ' annotate'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [buildout]
    allow-hosts= *
        DEFAULT_VALUE
    allow-picked-versions= true
        DEFAULT_VALUE
    bin-directory= bin
        DEFAULT_VALUE
    develop= recipes
        /sample-buildout/buildout.cfg
    develop-eggs-directory= develop-eggs
        DEFAULT_VALUE
    directory= /sample-buildout
        COMPUTED_VALUE
    eggs-directory= eggs
        DEFAULT_VALUE
    executable= ...
        DEFAULT_VALUE
    find-links=
        DEFAULT_VALUE
    install-from-cache= false
        DEFAULT_VALUE
    installed= .installed.cfg
        DEFAULT_VALUE
    log-format=
        DEFAULT_VALUE
    log-level= INFO
        DEFAULT_VALUE
    newest= true
        DEFAULT_VALUE
    offline= false
        DEFAULT_VALUE
    parts= data-dir
        /sample-buildout/buildout.cfg
    parts-directory= parts
        DEFAULT_VALUE
    prefer-final= true
        DEFAULT_VALUE
    python= buildout
        DEFAULT_VALUE
    show-picked-versions= false
        DEFAULT_VALUE
    socket-timeout=
        DEFAULT_VALUE
    update-versions-file=
        DEFAULT_VALUE
    use-dependency-links= true
        DEFAULT_VALUE
    versions= versions
        DEFAULT_VALUE
    <BLANKLINE>
    [data-dir]
    path= foo bins
        /sample-buildout/buildout.cfg
    recipe= recipes:mkdir
        /sample-buildout/buildout.cfg
    <BLANKLINE>
    [versions]
    zc.buildout= >=1.99
        DEFAULT_VALUE
    zc.recipe.egg= >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

Variable substitutions
----------------------

Buildout configuration files support variable substitution.
To illustrate this, we'll create an debug recipe to
allow us to see interactions with the buildout:

    >>> write(sample_buildout, 'recipes', 'debug.py',
    ... """
    ... import sys
    ... class Debug:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         for option, value in sorted(self.options.items()):
    ...             sys.stdout.write('%s %s\\n' % (option, value))
    ...         return ()
    ...
    ...     update = install
    ... """)

This recipe doesn't actually create anything. The install method
doesn't return anything, because it didn't create any files or
directories.

We also have to update our setup script:

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... ''')
    ... setup(name="recipes", entry_points=entry_points)
    ... """)

We've rearranged the script a bit to make the entry points easier to
edit.  In particular, entry points are now defined as a configuration
string, rather than a dictionary.

Let's update our configuration to provide variable substitution
examples:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

We used a string-template substitution for File-1 and File-2.  This
type of substitution uses the string.Template syntax.  Names
substituted are qualified option names, consisting of a section name
and option name joined by a colon.

Now, if we run the buildout, we'll see the options with the values
substituted.

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

Note that the substitution of the data-dir path option reflects the
update to the option performed by the mkdir recipe.

It might seem surprising that mydata was created again.  This is
because we changed our recipes package by adding the debug module.
The buildout system didn't know if this module could effect the mkdir
recipe, so it assumed it could and reinstalled mydata.  If we rerun
the buildout:

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating data-dir.
    Updating debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

We can see that mydata was not recreated.

Note that, in this case, we didn't specify a log level, so
we didn't get output about what the buildout was doing.

Section and option names in variable substitutions are only allowed to
contain alphanumeric characters, hyphens, periods and spaces. This
restriction might be relaxed in future releases.

We can ommit the section name in a variable substitution to refer to
the current section.  We can also use the special option,
_buildout_section_name_ to get the current section name.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${:File-1}/log
    ... my_name = ${:_buildout_section_name_}
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Updating data-dir.
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    my_name debug
    recipe recipes:debug

Automatic part selection and ordering
-------------------------------------

When a section with a recipe is referred to, either through variable
substitution or by an initializing recipe, the section is treated as a
part and added to the part list before the referencing part.  For
example, we can leave data-dir out of the parts list:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)


It will still be treated as a part:

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Updating data-dir.
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

    >>> cat('.installed.cfg') # doctest: +ELLIPSIS
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir debug
    ...

Note that the data-dir part is included *before* the debug part,
because the debug part refers to the data-dir part.  Even if we list
the data-dir part after the debug part, it will be included before:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug data-dir
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)


It will still be treated as a part:

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating data-dir.
    Updating debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

    >>> cat('.installed.cfg') # doctest: +ELLIPSIS
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir debug
    ...

Extending sections (macros)
---------------------------

A section (other than the buildout section) can extend one or more
other sections using the ``<`` option.  Options from the referenced
sections are copied to the referring section *before* variable
substitution.  This, together with the ability to refer to variables
of the current section allows sections to be used as macros.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = myfiles
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ...
    ... [with_file1]
    ... <= debug
    ... file1 = ${:path}/file1
    ... color = red
    ...
    ... [with_file2]
    ... <= debug
    ... file2 = ${:path}/file2
    ... color = blue
    ...
    ... [myfiles]
    ... <= with_file1
    ...    with_file2
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Uninstalling data-dir.
    Installing myfiles.
    color blue
    file1 mydata/file1
    file2 mydata/file2
    path mydata
    recipe recipes:debug

In this example, the debug, with_file1 and with_file2 sections act as
macros. In particular, the variable substitutions are performed
relative to the myfiles section.

Adding and removing options
---------------------------

We can append and remove values to an option by using the + and -
operators.

This is illustrated below; first we define a base configuration.

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... parts = part1 part2 part3
    ...
    ... [part1]
    ... recipe =
    ... option = a1 a2
    ...
    ... [part2]
    ... recipe =
    ... option = b1 b2 b3 b4
    ...
    ... [part3]
    ... recipe =
    ... option = c1 c2
    ...
    ... """)

Extending this configuration, we can "adjust" the values set in the
base configuration file.

    >>> write(sample_buildout, 'extension1.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... # appending values
    ... [part1]
    ... option += a3 a4
    ...
    ... # removing values
    ... [part2]
    ... option -= b1 b2
    ...
    ... # alt. spelling
    ... [part3]
    ... option+=c3 c4 c5
    ...
    ... # normal assignment
    ... [part4]
    ... option = h1 h2
    ...
    ... """)

An additional extension.

    >>> write(sample_buildout, 'extension2.cfg',
    ... """
    ... [buildout]
    ... extends = extension1.cfg
    ...
    ... # appending values
    ... [part1]
    ... option += a5
    ...
    ... # removing values
    ... [part2]
    ... option -= b1 b2 b3
    ...
    ... """)

To verify that the options are adjusted correctly, we'll set up an
extension that prints out the options.

    >>> mkdir(sample_buildout, 'demo')
    >>> write(sample_buildout, 'demo', 'demo.py',
    ... """
    ... import sys
    ... def ext(buildout):
    ...     sys.stdout.write(str(
    ...         [part['option'] for name, part in sorted(buildout.items())
    ...          if name.startswith('part')])+'\\n')
    ... """)

    >>> write(sample_buildout, 'demo', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name="demo",
    ...     entry_points={'zc.buildout.extension': ['ext = demo:ext']},
    ...     )
    ... """)

Set up a buildout configuration for this extension.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... parts =
    ... """)

    >>> os.chdir(sample_buildout)
    >>> print_(system(os.path.join(sample_buildout, 'bin', 'buildout')), end='')
    ... # doctest: +ELLIPSIS
    Develop: '/sample-buildout/demo'...

Verify option values.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... extensions = demo
    ... extends = extension2.cfg
    ... """)

    >>> print_(system(os.path.join('bin', 'buildout')), end='')
    ['a1 a2/na3 a4/na5', 'b1 b2 b3 b4', 'c1 c2/nc3 c4 c5', 'h1 h2']
    Develop: '/sample-buildout/demo'

Annotated sections output shows which files are responsible for which
operations.

    >>> print_(system(os.path.join('bin', 'buildout') + ' annotate'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    ...
    <BLANKLINE>
    [part1]
    option= a1 a2
    a3 a4
    a5
        /sample-buildout/base.cfg
    +=  /sample-buildout/extension1.cfg
    +=  /sample-buildout/extension2.cfg
    recipe=
        /sample-buildout/base.cfg
    <BLANKLINE>
    [part2]
    option= b1 b2 b3 b4
        /sample-buildout/base.cfg
    -=  /sample-buildout/extension1.cfg
    -=  /sample-buildout/extension2.cfg
    recipe=
        /sample-buildout/base.cfg
    <BLANKLINE>
    [part3]
    option= c1 c2
    c3 c4 c5
        /sample-buildout/base.cfg
    +=  /sample-buildout/extension1.cfg
    recipe=
        /sample-buildout/base.cfg
    <BLANKLINE>
    [part4]
    option= h1 h2
        /sample-buildout/extension1.cfg
    [versions]
    zc.buildout= >=1.99
        DEFAULT_VALUE
    zc.recipe.egg= >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

Cleanup.

    >>> os.remove(os.path.join(sample_buildout, 'base.cfg'))
    >>> os.remove(os.path.join(sample_buildout, 'extension1.cfg'))
    >>> os.remove(os.path.join(sample_buildout, 'extension2.cfg'))

Multiple configuration files
----------------------------

A configuration file can "extend" another configuration file.
Options are read from the other configuration file if they aren't
already defined by your configuration file.

The configuration files your file extends can extend
other configuration files.  The same file may be
used more than once although, of course, cycles aren't allowed.

To see how this works, we use an example:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op = buildout
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = base
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    op buildout
    recipe recipes:debug

The example is pretty trivial, but the pattern it illustrates is
pretty common.  In a more practical example, the base buildout might
represent a product and the extending buildout might be a
customization.

Here is a more elaborate example.

    >>> other = tmpdir('other')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = b1.cfg b2.cfg %(b3)s
    ...
    ... [debug]
    ... op = buildout
    ... """ % dict(b3=os.path.join(other, 'b3.cfg')))

    >>> write(sample_buildout, 'b1.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op1 = b1 1
    ... op2 = b1 2
    ... """)

    >>> write(sample_buildout, 'b2.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op2 = b2 2
    ... op3 = b2 3
    ... """)

    >>> write(other, 'b3.cfg',
    ... """
    ... [buildout]
    ... extends = b3base.cfg
    ...
    ... [debug]
    ... op4 = b3 4
    ... """)

    >>> write(other, 'b3base.cfg',
    ... """
    ... [debug]
    ... op5 = b3base 5
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = base
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    recipe recipes:debug

There are several things to note about this example:

- We can name multiple files in an extends option.

- We can reference files recursively.

- Relative file names in extended options are interpreted relative to
  the directory containing the referencing configuration file.

Loading Configuration from URLs
-------------------------------

Configuration files can be loaded from URLs.  To see how this works,
we'll set up a web server with some configuration files.

    >>> server_data = tmpdir('server_data')

    >>> write(server_data, "r1.cfg",
    ... """
    ... [debug]
    ... op1 = r1 1
    ... op2 = r1 2
    ... """)

    >>> write(server_data, "r2.cfg",
    ... """
    ... [buildout]
    ... extends = r1.cfg
    ...
    ... [debug]
    ... op2 = r2 2
    ... op3 = r2 3
    ... """)

    >>> server_url = start_server(server_data)

    >>> write('client.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... extends = %(url)s/r2.cfg
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = base
    ... """ % dict(url=server_url))


    >>> print_(system(buildout+ ' -c client.cfg'), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op1 r1 1
    op2 r2 2
    op3 r2 3
    recipe recipes:debug

Here we specified a URL for the file we extended.  The file we
downloaded, itself referred to a file on the server using a relative
URL reference.  Relative references are interpreted relative to the
base URL when they appear in configuration files loaded via URL.

We can also specify a URL as the configuration file to be used by a
buildout.

    >>> os.remove('client.cfg')
    >>> write(server_data, 'remote.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... extends = r2.cfg
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = remote
    ... """)

    >>> print_(system(buildout + ' -c ' + server_url + '/remote.cfg'), end='')
    While:
      Initializing.
    Error: Missing option: buildout:directory

Normally, the buildout directory defaults to directory
containing a configuration file.  This won't work for configuration
files loaded from URLs.  In this case, the buildout directory would
normally be defined on the command line:

    >>> print_(system(buildout
    ...              + ' -c ' + server_url + '/remote.cfg'
    ...              + ' buildout:directory=' + sample_buildout
    ...              ), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name remote
    op1 r1 1
    op2 r2 2
    op3 r2 3
    recipe recipes:debug

User defaults
-------------

If the file $HOME/.buildout/default.cfg, exists, it is read before
reading the configuration file.  ($HOME is the value of the HOME
environment variable. The '/' is replaced by the operating system file
delimiter.)

    >>> old_home = os.environ['HOME']
    >>> home = tmpdir('home')
    >>> mkdir(home, '.buildout')
    >>> write(home, '.buildout', 'default.cfg',
    ... """
    ... [debug]
    ... op1 = 1
    ... op7 = 7
    ... """)

    >>> os.environ['HOME'] = home
    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    op7 7
    recipe recipes:debug

A buildout command-line argument, -U, can be used to suppress reading
user defaults:

    >>> print_(system(buildout + ' -U'), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    recipe recipes:debug

    >>> os.environ['HOME'] = old_home

Log level
---------

We can control the level of logging by specifying a log level in out
configuration file.  For example, so suppress info messages, we can
set the logging level to WARNING

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... log-level = WARNING
    ... extends = b1.cfg b2.cfg
    ... """)

    >>> print_(system(buildout), end='')
    name base
    op1 b1 1
    op2 b2 2
    op3 b2 3
    recipe recipes:debug

Socket timeout
--------------

The timeout of the connections to egg and configuration servers can be
configured in the buildout section. Its value is configured in seconds.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... socket-timeout = 5
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = timeout
    ... """)

    >>> print_(system(buildout), end='')
    Setting socket time out to 5 seconds.
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    op timeout
    recipe recipes:debug

If the socket-timeout is not numeric, a warning is issued and the default
timeout of the Python socket module is used.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... socket-timeout = 5s
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = timeout
    ... """)

    >>> print_(system(buildout), end='')
    Default socket timeout is used !
    Value in configuration is not numeric: [5s].
    <BLANKLINE>
    Develop: '/sample-buildout/recipes'
    Updating debug.
    op timeout
    recipe recipes:debug

Uninstall recipes
-----------------

As we've seen, when parts are installed, buildout keeps track of files
and directories that they create. When the parts are uninstalled these
files and directories are deleted.

Sometimes more clean up is needed. For example, a recipe might add a
system service by calling chkconfig --add during installation. Later
during uninstallation, chkconfig --del will need to be called to
remove the system service.

In order to deal with these uninstallation issues, you can register
uninstall recipes. Uninstall recipes are registered using the
'zc.buildout.uninstall' entry point. Parts specify uninstall recipes
using the 'uninstall' option.

In comparison to regular recipes, uninstall recipes are much
simpler. They are simply callable objects that accept the name of the
part to be uninstalled and the part's options dictionary. Uninstall
recipes don't have access to the part itself since it maybe not be
able to be instantiated at uninstallation time.

Here's a recipe that simulates installation of a system service, along
with an uninstall recipe that simulates removing the service.

    >>> write(sample_buildout, 'recipes', 'service.py',
    ... """
    ... import sys
    ... class Service:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         sys.stdout.write("chkconfig --add %s\\n"
    ...                          % self.options['script'])
    ...         return ()
    ...
    ...     def update(self):
    ...         pass
    ...
    ...
    ... def uninstall_service(name, options):
    ...     sys.stdout.write("chkconfig --del %s\\n" % options['script'])
    ... """)

To use these recipes we must register them using entry points. Make
sure to use the same name for the recipe and uninstall recipe. This is
required to let buildout know which uninstall recipe goes with which
recipe.

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... service = service:Service
    ...
    ... [zc.buildout.uninstall]
    ... service = service:uninstall_service
    ... ''')
    ... setup(name="recipes", entry_points=entry_points)
    ... """)

Here's how these recipes could be used in a buildout:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = service
    ...
    ... [service]
    ... recipe = recipes:service
    ... script = /path/to/script
    ... """)

When the buildout is run the service will be installed

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing service.
    chkconfig --add /path/to/script

The service has been installed. If the buildout is run again with no
changes, the service shouldn't be changed.

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating service.

Now we change the service part to trigger uninstallation and
re-installation.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = service
    ...
    ... [service]
    ... recipe = recipes:service
    ... script = /path/to/a/different/script
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling service.
    Running uninstall recipe.
    chkconfig --del /path/to/script
    Installing service.
    chkconfig --add /path/to/a/different/script

Now we remove the service part, and add another part.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling service.
    Running uninstall recipe.
    chkconfig --del /path/to/a/different/script
    Installing debug.
    recipe recipes:debug

Uninstall recipes don't have to take care of removing all the files
and directories created by the part. This is still done automatically,
following the execution of the uninstall recipe. An upshot is that an
uninstallation recipe can access files and directories created by a
recipe before they are deleted.

For example, here's an uninstallation recipe that simulates backing up
a directory before it is deleted. It is designed to work with the
mkdir recipe introduced earlier.

    >>> write(sample_buildout, 'recipes', 'backup.py',
    ... """
    ... import os, sys
    ... def backup_directory(name, options):
    ...     path = options['path']
    ...     size = len(os.listdir(path))
    ...     sys.stdout.write("backing up directory %s of size %s\\n"
    ...                      % (path, size))
    ... """)

It must be registered with the zc.buildout.uninstall entry
point. Notice how it is given the name 'mkdir' to associate it with
the mkdir recipe.

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... service = service:Service
    ...
    ... [zc.buildout.uninstall]
    ... uninstall_service = service:uninstall_service
    ... mkdir = backup:backup_directory
    ... ''')
    ... setup(name="recipes", entry_points=entry_points)
    ... """)

Now we can use it with a mkdir part.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = dir debug
    ...
    ... [dir]
    ... recipe = recipes:mkdir
    ... path = my_directory
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

Run the buildout to install the part.

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing dir.
    dir: Creating directory my_directory
    Installing debug.
    recipe recipes:debug

Now we remove the part from the configuration file.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

When the buildout is run the part is removed, and the uninstall recipe
is run before the directory is deleted.

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling dir.
    Running uninstall recipe.
    backing up directory /sample-buildout/my_directory of size 0
    Updating debug.
    recipe recipes:debug

Now we will return the registration to normal for the benefit of the
rest of the examples.

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... ''')
    ... setup(name="recipes", entry_points=entry_points)
    ... """)


Command-line usage
------------------

A number of arguments can be given on the buildout command line.  The
command usage is::

  buildout [options and assignments] [command [command arguments]]

The following options are supported:

-h (or --help)
    Print basic usage information.  If this option is used, then all
    other options are ignored.

-c filename
    The -c option can be used to specify a configuration file, rather than
    buildout.cfg in the current directory.


-t socket_timeout

   Specify the socket timeout in seconds.

-v
    Increment the verbosity by 10.  The verbosity is used to adjust
    the logging level.  The verbosity is subtracted from the numeric
    value of the log-level option specified in the configuration file.

-q
    Decrement the verbosity by 10.

-U
    Don't read user-default configuration.

-o
    Run in off-line mode.  This is equivalent to the assignment
    buildout:offline=true.

-O
    Run in non-off-line mode.  This is equivalent to the assignment
    buildout:offline=false.  This is the default buildout mode.  The
    -O option would normally be used to override a true offline
    setting in a configuration file.

-n
    Run in newest mode.  This is equivalent to the assignment
    buildout:newest=true.  With this setting, which is the default,
    buildout will try to find the newest versions of distributions
    available that satisfy its requirements.

-N
    Run in non-newest mode.  This is equivalent to the assignment
    buildout:newest=false.  With this setting, buildout will not seek
    new distributions if installed distributions satisfy it's
    requirements.

Assignments are of the form::

  section_name:option_name=value

Or::

  option_name=value

which is equivalent to::

  buildout:option_name=value

Options and assignments can be given in any order.

Here's an example:

    >>> write(sample_buildout, 'other.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... installed = .other.cfg
    ... log-level = WARNING
    ...
    ... [debug]
    ... name = other
    ... recipe = recipes:debug
    ... """)

Note that we used the installed buildout option to specify an
alternate file to store information about installed parts.

    >>> print_(system(buildout+' -c other.cfg debug:op1=foo -v'), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    name other
    op1 foo
    recipe recipes:debug

Here we used the -c option to specify an alternate configuration file,
and the -v option to increase the level of logging from the default,
WARNING.

Options can also be combined in the usual Unix way, as in:

    >>> print_(system(buildout+' -vcother.cfg debug:op1=foo'), end='')
    Develop: '/sample-buildout/recipes'
    Updating debug.
    name other
    op1 foo
    recipe recipes:debug

Here we combined the -v and -c options with the configuration file
name.  Note that the -c option has to be last, because it takes an
argument.

    >>> os.remove(os.path.join(sample_buildout, 'other.cfg'))
    >>> os.remove(os.path.join(sample_buildout, '.other.cfg'))

The most commonly used command is 'install' and it takes a list of
parts to install. if any parts are specified, only those parts are
installed.  To illustrate this, we'll update our configuration and run
the buildout in the usual way:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d1 d2 d3
    ...
    ... [d1]
    ... recipe = recipes:mkdir
    ... path = d1
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = d2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = d3
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    recipe recipes:debug
    Installing d1.
    d1: Creating directory d1
    Installing d2.
    d2: Creating directory d2
    Installing d3.
    d3: Creating directory d3

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  d3
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

    >>> cat(sample_buildout, '.installed.cfg')
    ... # doctest: +NORMALIZE_WHITESPACE
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = debug d1 d2 d3
    <BLANKLINE>
    [debug]
    __buildout_installed__ =
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    recipe = recipes:debug
    <BLANKLINE>
    [d1]
    __buildout_installed__ = /sample-buildout/d1
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d1
    recipe = recipes:mkdir
    <BLANKLINE>
    [d2]
    __buildout_installed__ = /sample-buildout/d2
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = /sample-buildout/d3
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d3
    recipe = recipes:mkdir

Now we'll update our configuration file:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d2 d3 d4
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = data2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = data3
    ...
    ... [d4]
    ... recipe = recipes:mkdir
    ... path = ${d2:path}-extra
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... x = 1
    ... """)

and run the buildout specifying just d3 and d4:

    >>> print_(system(buildout+' install d3 d4'), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling d3.
    Installing d3.
    d3: Creating directory data3
    Installing d4.
    d4: Creating directory data2-extra

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  data2-extra
    d  data3
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

Only the d3 and d4 recipes ran.  d3 was removed and data3 and data2-extra
were created.

The .installed.cfg is only updated for the recipes that ran:

    >>> cat(sample_buildout, '.installed.cfg')
    ... # doctest: +NORMALIZE_WHITESPACE
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = debug d1 d2 d3 d4
    <BLANKLINE>
    [debug]
    __buildout_installed__ =
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    recipe = recipes:debug
    <BLANKLINE>
    [d1]
    __buildout_installed__ = /sample-buildout/d1
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d1
    recipe = recipes:mkdir
    <BLANKLINE>
    [d2]
    __buildout_installed__ = /sample-buildout/d2
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = /sample-buildout/data3
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/data3
    recipe = recipes:mkdir
    <BLANKLINE>
    [d4]
    __buildout_installed__ = /sample-buildout/data2-extra
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/data2-extra
    recipe = recipes:mkdir

Note that the installed data for debug, d1, and d2 haven't changed,
because we didn't install those parts and that the d1 and d2
directories are still there.

Now, if we run the buildout without the install command:

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling d2.
    Uninstalling d1.
    Uninstalling debug.
    Installing debug.
    recipe recipes:debug
    x 1
    Installing d2.
    d2: Creating directory data2
    Updating d3.
    Updating d4.

We see the output of the debug recipe and that data2 was created.  We
also see that d1 and d2 have gone away:

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  data2
    d  data2-extra
    d  data3
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

Alternate directory and file locations
--------------------------------------

The buildout normally puts the bin, eggs, and parts directories in the
directory in the directory containing the configuration file. You can
provide alternate locations, and even names for these directories.

    >>> alt = tmpdir('sample-alt')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... develop-eggs-directory = %(developbasket)s
    ... eggs-directory = %(basket)s
    ... bin-directory = %(scripts)s
    ... parts-directory = %(work)s
    ... """ % dict(
    ...    developbasket = os.path.join(alt, 'developbasket'),
    ...    basket = os.path.join(alt, 'basket'),
    ...    scripts = os.path.join(alt, 'scripts'),
    ...    work = os.path.join(alt, 'work'),
    ... ))

    >>> print_(system(buildout), end='')
    Creating directory '/sample-alt/scripts'.
    Creating directory '/sample-alt/work'.
    Creating directory '/sample-alt/basket'.
    Creating directory '/sample-alt/developbasket'.
    Develop: '/sample-buildout/recipes'
    Uninstalling d4.
    Uninstalling d3.
    Uninstalling d2.
    Uninstalling debug.

    >>> ls(alt)
    d  basket
    d  developbasket
    d  scripts
    d  work

    >>> ls(alt, 'developbasket')
    -  recipes.egg-link

You can also specify an alternate buildout directory:

    >>> rmdir(alt)
    >>> alt = tmpdir('sample-alt')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... directory = %(alt)s
    ... develop = %(recipes)s
    ... parts =
    ... """ % dict(
    ...    alt=alt,
    ...    recipes=os.path.join(sample_buildout, 'recipes'),
    ...    ))

    >>> print_(system(buildout), end='')
    Creating directory '/sample-alt/bin'.
    Creating directory '/sample-alt/parts'.
    Creating directory '/sample-alt/eggs'.
    Creating directory '/sample-alt/develop-eggs'.
    Develop: '/sample-buildout/recipes'

    >>> ls(alt)
    -  .installed.cfg
    d  bin
    d  develop-eggs
    d  eggs
    d  parts

    >>> ls(alt, 'develop-eggs')
    -  recipes.egg-link

Logging control
---------------

Three buildout options are used to control logging:

log-level
   specifies the log level

verbosity
   adjusts the log level

log-format
   allows an alternate logging for mat to be specified

We've already seen the log level and verbosity.  Let's look at an example
of changing the format:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... log-level = 25
    ... verbosity = 5
    ... log-format = %(levelname)s %(message)s
    ... """)

Here, we've changed the format to include the log-level name, rather
than the logger name.

We've also illustrated, with a contrived example, that the log level
can be a numeric value and that the verbosity can be specified in the
configuration file.  Because the verbosity is subtracted from the log
level, we get a final log level of 20, which is the INFO level.

    >>> print_(system(buildout), end='')
    INFO Develop: '/sample-buildout/recipes'

Predefined buildout options
---------------------------

Buildouts have a number of predefined options that recipes can use
and that users can override in their configuration files.  To see
these, we'll run a minimal buildout configuration with a debug logging
level.  One of the features of debug logging is that the configuration
database is shown.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... parts =
    ... """)

    >>> print_(system(buildout+' -vv'), end='') # doctest: +NORMALIZE_WHITESPACE
    Installing 'zc.buildout', 'distribute'.
    We have a develop egg: zc.buildout 1.0.0.
    We have the best distribution that satisfies 'distribute'.
    Picked: distribute = 0.6
    <BLANKLINE>
    Configuration data:
    [buildout]
    allow-hosts = *
    allow-picked-versions = true
    bin-directory = /sample-buildout/bin
    develop-eggs-directory = /sample-buildout/develop-eggs
    directory = /sample-buildout
    eggs-directory = /sample-buildout/eggs
    executable = python
    find-links =
    install-from-cache = false
    installed = /sample-buildout/.installed.cfg
    log-format =
    log-level = INFO
    newest = true
    offline = false
    parts =
    parts-directory = /sample-buildout/parts
    prefer-final = true
    python = buildout
    show-picked-versions = false
    socket-timeout =
    update-versions-file =
    use-dependency-links = true
    verbosity = 20
    versions = versions
    [versions]
    zc.buildout = >=1.99
    zc.recipe.egg = >=1.99
    <BLANKLINE>

All of these options can be overridden by configuration files or by
command-line assignments.  We've discussed most of these options
already, but let's review them and touch on some we haven't discussed:

allow-hosts
    On some environments the links visited by `zc.buildout` can be forbidden by
    paranoid firewalls. These URLs might be in the chain of links visited by
    `zc.buildout` as defined by buildout's `find-links` option, or as defined
    by various eggs in their `url`, `download_url`, `dependency_links` metadata.

    The fact that package_index works like a spider and might visit links and
    go to other locations makes this even harder.

    The `allow-hosts` option provides a way to prevent this, and
    works exactly like the one provided in `easy_install`.

    You can provide a list of allowed host, together with wildcards::

        [buildout]
        ...

        allow-hosts =
            *.python.org
            example.com

    All URLs that does not match these hosts will not be visited.

allow-picked-versions
    By default, the buildout will choose the best match for a given requirement
    if the requirement is not specified precisely (for instance, using the
    "versions" option.  This behavior corresponds to the
    "allow-picked-versions" being set to its default value, "true".  If
    "allow-picked-versions" is "false," instead of picking the best match,
    buildout will raise an error.  This helps enforce repeatability.

bin-directory
   The directory path where scripts are written.  This can be a
   relative path, which is interpreted relative to the directory
   option.

develop-eggs-directory
   The directory path where development egg links are created for software
   being created in the local project.  This can be a relative path,
   which is interpreted relative to the directory option.

directory
   The buildout directory.  This is the base for other buildout file
   and directory locations, when relative locations are used.

eggs-directory
   The directory path where downloaded eggs are put.  It is common to share
   this directory across buildouts. Eggs in this directory should
   *never* be modified.  This can be a relative path, which is
   interpreted relative to the directory option.

executable
   The Python executable used to run the buildout.  See the python
   option below.

find-links
    You can specify more locations to search for distributions using the
    `find-links` option. All locations specified will be searched for
    distributions along with the package index as described before.

    Locations can be urls::

      [buildout]
      ...
      find-links = http://download.zope.org/distribution/

    They can also be directories on disk::

      [buildout]
      ...
      find-links = /some/path

    Finally, they can also be direct paths to distributions::

      [buildout]
      ...
      find-links = /some/path/someegg-1.0.0-py2.3.egg

    Any number of locations can be specified in the `find-links` option::

      [buildout]
      ...
      find-links =
          http://download.zope.org/distribution/
          /some/otherpath
          /some/path/someegg-1.0.0-py2.3.egg

install-from-cache
    A download cache can be used as the basis of application source releases.
    In an application source release, we want to distribute an application that
    can be built without making any network accesses.  In this case, we
    distribute a buildout with download cache and tell the buildout to install
    from the download cache only, without making network accesses.  The
    buildout install-from-cache option can be used to signal that packages
    should be installed only from the download cache.

installed
   The file path where information about the results of the previous
   buildout run is written.  This can be a relative path, which is
   interpreted relative to the directory option.  This file provides
   an inventory of installed parts with information needed to decide
   which if any parts need to be uninstalled.

log-format
   The format used for logging messages.

log-level
   The log level before verbosity adjustment

newest
    By default buildout and recipes will try to find the newest versions of
    distributions needed to satisfy requirements.  This can be very time
    consuming, especially when incrementally working on setting up a buildout
    or working on a recipe.  The buildout "newest" option can be used to to
    suppress this.  If the "newest" option is set to false, then new
    distributions won't be sought if an installed distribution meets
    requirements.  The "newest" option can also be set to false using the -N
    command-line option.  See also the "offline" option.

offline
    The "offline" option goes a bit further than the "newest" option.  If the
    buildout "offline" option is given a value of "true", the buildout and
    recipes that are aware of the option will avoid doing network access.  This
    is handy when running the buildout when not connected to the internet.  It
    also makes buildouts run much faster. This option is typically set using
    the buildout -o option.

parts
   A white space separated list of parts to be installed.

parts-directory
   A working directory that parts can used to store data.

prefer-final
    Currently, when searching for new releases, the newest available
    release is used.  This isn't usually ideal, as you may get a
    development release or alpha releases not ready to be widely used.
    You can request that final releases be preferred using the prefer
    final option in the buildout section::

      [buildout]
      ...
      prefer-final = true

    When the prefer-final option is set to true, then when searching for
    new releases, final releases are preferred.  If there are final
    releases that satisfy distribution requirements, then those releases
    are used even if newer non-final releases are available.  The buildout
    prefer-final option can be used to override this behavior.

    In buildout version 2, final releases will be preferred by default.
    You will then need to use a false value for prefer-final to get the
    newest releases.

python
   The name of a section containing information about the default
   Python interpreter.  Recipes that need a installation
   typically have options to tell them which Python installation to
   use.  By convention, if a section-specific option isn't used, the
   option is looked for in the buildout section.  The option must
   point to a section with an executable option giving the path to a
   Python executable.  By default, the buildout section defines the
   default Python as the Python used to run the buildout.

use-dependency-links
    By default buildout will obey the setuptools dependency_links metadata
    when it looks for dependencies. This behavior can be controlled with
    the use-dependency-links buildout option::

      [buildout]
      ...
      use-dependency-links = false

    The option defaults to true. If you set it to false, then dependency
    links are only looked for in the locations specified by find-links.

verbosity
   A log-level adjustment.  Typically, this is set via the -q and -v
   command-line options.


Creating new buildouts and bootstrapping
----------------------------------------

If zc.buildout is installed, you can use it to create a new buildout
with it's own local copies of zc.buildout and distribute and with
local buildout scripts.

    >>> sample_bootstrapped = tmpdir('sample-bootstrapped')

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped, 'setup.cfg')
    ...              +' init'), end='')
    Creating '/sample-bootstrapped/setup.cfg'.
    Creating directory '/sample-bootstrapped/bin'.
    Creating directory '/sample-bootstrapped/parts'.
    Creating directory '/sample-bootstrapped/eggs'.
    Creating directory '/sample-bootstrapped/develop-eggs'.
    Generated script '/sample-bootstrapped/bin/buildout'.

Note that a basic setup.cfg was created for us.  This is because we
provided an 'init' argument.  By default, the generated
``setup.cfg`` is as minimal as it could be:

    >>> cat(sample_bootstrapped, 'setup.cfg')
    [buildout]
    parts =

We also get other buildout artifacts:

    >>> ls(sample_bootstrapped)
    d  bin
    d  develop-eggs
    d  eggs
    d  parts
    -  setup.cfg

    >>> ls(sample_bootstrapped, 'bin')
    -  buildout

    >>> _ = (ls(sample_bootstrapped, 'eggs'),
    ...      ls(sample_bootstrapped, 'develop-eggs'))
    -  distribute-0.6-py2.3.egg
    -  zc.buildout-1.0-py2.3.egg

(We list both the eggs and develop-eggs directories because the
buildout or distribute egg could be installed in the develop-eggs
directory if the original buildout had develop eggs for either
buildout or distribute.)

Note that the buildout script was installed but not run.  To run
the buildout, we'd have to run the installed buildout script.

If we have an existing buildout that already has a buildout.cfg, we'll
normally use the bootstrap command instead of init.  It will complain
if there isn't a configuration file:

    >>> sample_bootstrapped2 = tmpdir('sample-bootstrapped2')

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped2, 'setup.cfg')
    ...              +' bootstrap'), end='')
    While:
      Initializing.
    Error: Couldn't open /sample-bootstrapped2/setup.cfg

    >>> write(sample_bootstrapped2, 'setup.cfg',
    ... """
    ... [buildout]
    ... parts =
    ... """)

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped2, 'setup.cfg')
    ...              +' bootstrap'), end='')
    Creating directory '/sample-bootstrapped2/bin'.
    Creating directory '/sample-bootstrapped2/parts'.
    Creating directory '/sample-bootstrapped2/eggs'.
    Creating directory '/sample-bootstrapped2/develop-eggs'.
    Generated script '/sample-bootstrapped2/bin/buildout'.

Similarly, if there is a configuration file and we use the init
command, we'll get an error that the configuration file already
exists:

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped, 'setup.cfg')
    ...              +' init'), end='')
    While:
      Initializing.
    Error: '/sample-bootstrapped/setup.cfg' already exists.

Initial eggs
------------

When using the ``init`` command, you can specify distribution requirements
or paths to use:

    >>> cd(sample_bootstrapped)
    >>> remove('setup.cfg')
    >>> print_(system(buildout + ' -csetup.cfg init demo other ./src'), end='')
    Creating '/sample-bootstrapped/setup.cfg'.
    Getting distribution for 'zc.recipe.egg>=2.0.0a3'.
    Got zc.recipe.egg
    Installing py.
    Getting distribution for 'demo'.
    Got demo 0.3.
    Getting distribution for 'other'.
    Got other 1.0.
    Getting distribution for 'demoneeded'.
    Got demoneeded 1.1.
    Generated script '/sample-bootstrapped/bin/demo'.
    Generated script '/sample-bootstrapped/bin/distutilsscript'.
    Generated interpreter '/sample-bootstrapped/bin/py'.

This causes a ``py`` part to be included that sets up a custom python
interpreter with the given requirements or paths:

    >>> cat('setup.cfg')
    [buildout]
    parts = py
    <BLANKLINE>
    [py]
    recipe = zc.recipe.egg
    interpreter = py
    eggs =
      demo
      other
    extra-paths =
      ./src

Passing requirements or paths causes the the builout to be run as part
of initialization.  In the example above, we got a number of
distributions installed and 2 scripts generated.  The first, ``demo``,
was defined by the ``demo`` project. The second, ``py`` was defined by
the generated configuration.  It's a "custom interpreter" that behaves
like a standard Python interpeter, except that includes the specified
eggs and extra paths in it's Python path.

We specified a source directory that didn't exist. Buildout created it
for us:

    >>> ls('.')
    -  .installed.cfg
    d  bin
    d  develop-eggs
    d  eggs
    d  parts
    -  setup.cfg
    d  src

    >>> uncd()

.. Make sure it works if the dir is already there:

    >>> cd(sample_bootstrapped)
    >>> _ = system(buildout + ' -csetup.cfg buildout:parts=')
    >>> remove('setup.cfg')
    >>> print_(system(buildout + ' -csetup.cfg init demo other ./src'), end='')
    Creating '/sample-bootstrapped/setup.cfg'.
    Installing py.
    Generated script '/sample-bootstrapped/bin/demo'.
    Generated script '/sample-bootstrapped/bin/distutilsscript'.
    Generated interpreter '/sample-bootstrapped/bin/py'.

.. cleanup

    >>> _ = system(buildout + ' -csetup.cfg buildout:parts=')
    >>> uncd()

Finding distributions
---------------------

By default, buildout searches the Python Package Index when looking
for distributions. You can, instead, specify your own index to search
using the `index` option::

  [buildout]
  ...
  index = http://index.example.com/

This index, or the default of http://pypi.python.org/simple/ if no
index is specified, will always be searched for distributions unless
running buildout with options that prevent searching for
distributions. The latest version of the distribution that meets the
requirements of the buildout will always be used.

You can also specify more locations to search for distributions using
the `find-links` option. See its description above.

Controlling the installation database
-------------------------------------

The buildout installed option is used to specify the file used to save
information on installed parts.  This option is initialized to
".installed.cfg", but it can be overridden in the configuration file
or on the command line:

    >>> write('buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print_(system(buildout+' buildout:installed=inst.cfg'), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    recipe recipes:debug

    >>> ls(sample_buildout)
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  demo
    d  develop-eggs
    d  eggs
    -  inst.cfg
    d  parts
    d  recipes

The installation database can be disabled by supplying an empty
buildout installed option:

    >>> os.remove('inst.cfg')
    >>> print_(system(buildout+' buildout:installed='), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    recipe recipes:debug

    >>> ls(sample_buildout)
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes


Note that there will be no installation database if there are no parts:

    >>> write('buildout.cfg',
    ... """
    ... [buildout]
    ... parts =
    ... """)

    >>> print_(system(buildout+' buildout:installed=inst.cfg'), end='')

    >>> ls(sample_buildout)
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

Extensions
----------

A feature allows code to be loaded and run after
configuration files have been read but before the buildout has begun
any processing.  The intent is to allow special plugins such as
urllib2 request handlers to be loaded.

To load an extension, we use the extensions option and list one or
more distribution requirements, on separate lines.  The distributions
named will be loaded and any ``zc.buildout.extension`` entry points found
will be called with the buildout as an argument.  When buildout
finishes processing, any ``zc.buildout.unloadextension`` entry points
found will be called with the buildout as an argument.

Let's create a sample extension in our sample buildout created in the
previous section:

    >>> mkdir(sample_bootstrapped, 'demo')

    >>> write(sample_bootstrapped, 'demo', 'demo.py',
    ... """
    ... import sys
    ... def ext(buildout):
    ...     sys.stdout.write('%s %s\\n' % ('ext', sorted(buildout)))
    ... def unload(buildout):
    ...     sys.stdout.write('%s %s\\n' % ('unload', sorted(buildout)))
    ... """)

    >>> write(sample_bootstrapped, 'demo', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name = "demo",
    ...     entry_points = {
    ...        'zc.buildout.extension': ['ext = demo:ext'],
    ...        'zc.buildout.unloadextension': ['ext = demo:unload'],
    ...        },
    ...     )
    ... """)

Our extension just prints out the word 'demo', and lists the sections
found in the buildout passed to it.

We'll update our buildout.cfg to list the demo directory as a develop
egg to be built:

    >>> write(sample_bootstrapped, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... parts =
    ... """)

    >>> os.chdir(sample_bootstrapped)
    >>> print_(system(os.path.join(sample_bootstrapped, 'bin', 'buildout')),
    ...        end='')
    Develop: '/sample-bootstrapped/demo'

Now we can add the extensions option.  We were a bit tricky and ran
the buildout once with the demo develop egg defined but without the
extension option.  This is because extensions are loaded before the
buildout creates develop eggs. We needed to use a separate buildout
run to create the develop egg.  Normally, when eggs are loaded from
the network, we wouldn't need to do anything special.

    >>> write(sample_bootstrapped, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... extensions = demo
    ... parts =
    ... """)

We see that our extension is loaded and executed:

    >>> print_(system(os.path.join(sample_bootstrapped, 'bin', 'buildout')),
    ...        end='')
    ext ['buildout', 'versions']
    Develop: '/sample-bootstrapped/demo'
    unload ['buildout', 'versions']
