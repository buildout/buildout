Buildouts
=========

The word "buildout" refers to a description of a set of parts and the
software to create and assemble them.  It is often used informally to
refer to an installed system based on a buildout definition.  For
example, if we are creating an application named "Foo", then "the Foo
buildout" is the collection of configuration and application-specific
software that allows an instance of the application to be created.  We
may refer to such an instance of the application informally as "a Foo
buildout".

This document describes how to define buildouts using buildout
configuration files and recipes.  There are three ways to set up the
buildout software and create a buildout instance:

1. Install the ``zc.buildout`` egg with ``easy_install`` and use the buildout
   script installed in a Python scripts area.

2. Use the buildout bootstrap script to create a buildout that
   includes both the ``setuptools`` and ``zc.buildout`` eggs.  This allows you
   to use the buildout software without modifying a Python install.
   The buildout script is installed into your buildout local scripts
   area.

3. Use a buildout command from an already installed buildout to
   bootstrap a new buildout.  (See the section on bootstrapping later
   in this document.)

Often, a software project will be managed in a software repository,
such as a subversion repository, that includes some software source
directories, buildout configuration files, and a copy of the buildout
bootstrap script.  To work on the project, one would check out the
project from the repository and run the bootstrap script which
installs ``setuptools`` and ``zc.buildout`` into the checkout as well as any
parts defined.

We have a sample buildout that we created using the bootstrap command
of an existing buildout (method 3 above).  It has the absolute minimum
information.  We have ``bin``, ``develop-eggs``, ``eggs`` and ``parts``
directories, and a configuration file::

    >>> print(sample_buildout)
    >>> print(sample_buildout)
    /sample-buildout
    >>> ls(sample_buildout)
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  parts

The ``bin`` directory contains scripts::

    >>> ls(sample_buildout, 'bin')
    -  buildout

The ``eggs`` directory has installed distributions:

    >>> ls(sample_buildout, 'eggs')
    -  packaging.egg-link
    -  pip.egg-link
    -  setuptools.egg-link
    -  wheel.egg-link
    -  zc.buildout.egg-link

The ``develop-eggs`` and ``parts`` directories are initially empty::

    >>> ls(sample_buildout, 'develop-eggs')
    >>> ls(sample_buildout, 'parts')

The ``develop-eggs`` directory holds egg links for software being
developed in the buildout.  We separate ``develop-eggs`` and other eggs to
allow eggs directories to be shared across multiple buildouts.  For
example, a common developer technique is to define a common eggs
directory in their home that all non-develop eggs are stored in.  This
allows larger buildouts to be set up much more quickly and saves disk
space.

The ``parts`` directory provides an area where recipes can install
part data.  For example, if we built a custom Python, we would
install it in the ``parts`` directory.  Part data is stored in a
sub-directory of the parts directory with the same name as the part.

Buildouts are defined using configuration files.  These are in the
format defined by the Python ``ConfigParser`` module, with extensions
that we'll describe later.  By default, when a buildout is run, it
looks for the file ``buildout.cfg`` in the directory where the buildout is
run.

The minimal configuration file has a ``buildout`` section that defines no
parts::

    >>> cat(sample_buildout, 'buildout.cfg')
    [buildout]
    parts =

A part is simply something to be created by a buildout.  It can be
almost anything, such as a Python package, a program, a directory, or
even a configuration file.

Recipes
-------

A part is created by a recipe.  Recipes are always installed as Python
eggs. They can be downloaded from a package server, such as the
Python Package Index, or they can be developed as part of a project
using a "develop" egg.

A develop egg is a special kind of egg that gets installed as an "egg
link" that contains the name of a source directory.  Develop eggs
don't have to be packaged for distribution to be used and can be
modified in place, which is especially useful while they are being
developed.

Let's create a recipe as part of the sample project.  We'll create a
recipe for creating directories.  First, we'll create a recipes source
directory for our local recipes::

    >>> mkdir(sample_buildout, 'recipes')

and then we'll create a source file for our ``mkdir`` recipe::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...         options['path'] = os.path.join(
    ...                               buildout['buildout']['directory'],
    ...                               options['path'],
    ...                               )
    ...         if not os.path.isdir(os.path.dirname(options['path'])):
    ...             logging.getLogger(self.name).error(
    ...                 'Cannot create %s. %s is not a directory.',
    ...                 options['path'], os.path.dirname(options['path']))
    ...             raise zc.buildout.UserError('Invalid Path')
    ...
    ...
    ...     def install(self):
    ...         path = self.options['path']
    ...         logging.getLogger(self.name).info(
    ...             'Creating directory %s', os.path.basename(path))
    ...         os.mkdir(path)
    ...         return path
    ...
    ...     def update(self):
    ...         pass
    ... """)

Currently, recipes must define 3 methods:

- a constructor,

- an install method, and

- an update method.

The constructor is responsible for updating a parts options to reflect
data read from other sections.  The buildout system keeps track of
whether a part specification has changed.  A part specification has
changed if it's options, after adjusting for data read from other
sections, has changed, or if the recipe has changed.  Only the options
for the part are considered.  If data are read from other sections,
then that information has to be reflected in the parts options.  In
the ``mkdir`` example, the given path is interpreted relative to the
buildout directory, and data from the buildout directory is read.  The
path option is updated to reflect this.  If the directory option was
changed in the buildout sections, we would know to update parts
created using the ``mkdir`` recipe using relative path names.

When buildout is run, it saves configuration data for installed parts
in a file named ``.installed.cfg``.  In subsequent runs, it compares
part-configuration data stored in the ``.installed.cfg`` file and the
part-configuration data loaded from the configuration files as
modified by recipe constructors to decide if the configuration of a
part has changed. If the configuration has changed, or if the recipe
has changed, then the part is uninstalled and reinstalled.  The
buildout only looks at the part's options, so any data used to
configure the part needs to be reflected in the part's options.  It is
the job of a recipe constructor to make sure that the options include
all relevant data.

Of course, parts are also uninstalled if they are no longer used.

The recipe defines a constructor that takes a buildout object, a part
name, and an options dictionary. It saves them in instance attributes.
If the path is relative, we'll interpret it as relative to the
buildout directory.  The buildout object passed in is a mapping from
section name to a mapping of options for that section. The buildout
directory is available as the directory option of the buildout
section.  We normalize the path and save it back into the options
directory.

The install method is responsible for creating the part.  In this
case, we need the path of the directory to create.  We'll use a path
option from our options dictionary.  The install method logs what it's
doing using the Python ``logging`` call.  We return the path that we
installed.  If the part is uninstalled or reinstalled, then the path
returned will be removed by the buildout machinery.  A recipe install
method is expected to return a string, or an iterable of strings
containing paths to be removed if a part is uninstalled.  For most
recipes, this is all of the uninstall support needed. For more complex
uninstallation scenarios, use `Uninstall recipes`_.

The update method is responsible for updating an already installed
part.  An empty method is often provided, as in this example, if parts
can't be updated.  An update method can return None, a string, or an
iterable of strings.  If a string or iterable of strings is returned,
then the saved list of paths to be uninstalled is updated with the new
information by adding any new files returned by the update method.

We need to provide packaging information so that our recipe can be
installed as a develop egg. The minimum information we need to specify
is a name.  For recipes, we also need to define the
names of the recipe classes as entry points.  Packaging information is
provided via a ``setup.py`` script::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name = "recipes",
    ...     entry_points = {'zc.buildout': ['mkdir = mkdir:Mkdir']},
    ...     )
    ... """)

Our setup script defines an *entry point*. Entry points provide
a way for an egg to define the services it provides.  Here we've said
that we define a ``zc.buildout`` entry point named ``mkdir``.  Recipe
classes must be exposed as entry points in the ``zc.buildout`` group.  We
give entry points names within the group.

We also need a ``README.txt`` for our recipes to avoid an annoying warning
from ``distutils`` (which ``setuptools`` and ``zc.buildout`` are based on)::

    >>> write(sample_buildout, 'recipes', 'README.txt', " ")

Now let's update our ``buildout.cfg``::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mystuff
    ... """)

Let's go through the changes one by one::

    develop = recipes

This tells the buildout to install a development egg for our recipes.
Any number of paths can be listed.  The paths can be relative or
absolute.  If relative, they are treated as relative to the buildout
directory.  They can be directory or file paths.  If a file path is
given, it should point to a Python setup script.  If a directory path
is given, it should point to a directory containing a ``setup.py`` file.
Development eggs are installed before building any parts, as they may
provide locally-defined recipes needed by the parts.

::

    parts = data-dir

Here we've named a part to be "built".  We can use any name we want,
except that part names have to be unique and recipes will often
use the part name to decide what to do.

::

    [data-dir]
    recipe = recipes:mkdir
    path = mystuff


When we name a part, we also create a section of the same
name that contains part data.  In this section, we'll define
the recipe to be used to install the part.  In this case, we also
specify the path to be created.

Let's run the buildout.  We do so by running the build script in the
buildout::

    >>> import os
    >>> os.getenv("HOME")
    >>> os.getenv("TMPDIR")
    >>> os.getenv("TMP")
    >>> os.getenv("TEMP")
    >>> os.chdir(sample_buildout)
    >>> print(os.getcwd())
    >>> buildout = os.path.join(sample_buildout, 'bin', 'buildout')
    >>> print_(system(buildout), end='')
    Develop: '...sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory mystuff

We see that the recipe created the directory, as expected::

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  mystuff
    d  parts
    d  recipes

In addition, .installed.cfg has been created containing information
about the part we installed::

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir
    <BLANKLINE>
    [data-dir]
    __buildout_installed__ = /sample-buildout/mystuff
    __buildout_signature__ = recipes-c7vHV6ekIDUPy/7fjAaYjg==
    path = /sample-buildout/mystuff
    recipe = recipes:mkdir

Note that the directory we installed is included in .installed.cfg.
In addition, the path option includes the actual destination
directory.

If we change the name of the directory in the configuration file,
we'll see that the directory gets removed and recreated::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  mydata
    d  parts
    d  recipes

If any of the files or directories created by a recipe are removed,
the part will be reinstalled::

    >>> rmdir(sample_buildout, 'mydata')
    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata

Error reporting
---------------

If a user makes an error the error needs to be reported, and work needs
to stop.  This is accomplished by logging a detailed error message and
then raising a
``zc.buildout.UserError`` exception (or a subclass of this exception).
Raising an error other than a
``UserError`` still displays the error, but labels it as a bug in the
buildout software or recipe. In the sample above, if someone gives a
non-existent directory to create the directory in::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = /xxx/mydata
    ... """)

we'll get a user error, not a traceback::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    data-dir: Cannot create .../xxx/mydata. .../xxx is not a directory.
    While:
      Installing.
      Getting section data-dir.
      Initializing section data-dir.
    Error: Invalid Path


Recipe Error Handling
---------------------

If an error occurs during installation, it is up to the recipe to
clean up any system side effects, such as files created.  Let's update
the ``mkdir`` recipe to support multiple paths::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         for path in paths:
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...         return paths
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

If there is an error creating a path, the install method will exit and
leave previously created paths in place::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bin
    ... """)

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

We meant to create a directory ``bins``, but typed ``bin``.  Now ``foo`` was
left behind::

    >>> os.path.exists('foo')
    True

If we fix the typo::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bins
    ... """)

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

Now they fail because ``foo`` exists, because it was left behind::

    >>> remove('foo')

Let's fix the recipe::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout, sys
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         created = []
    ...         try:
    ...             for path in paths:
    ...                 logging.getLogger(self.name).info(
    ...                     'Creating directory %s', os.path.basename(path))
    ...                 os.mkdir(path)
    ...                 created.append(path)
    ...         except Exception:
    ...             for d in created:
    ...                 os.rmdir(d)
    ...                 assert not os.path.exists(d)
    ...                 logging.getLogger(self.name).info(
    ...                     'Removed %s due to error',
    ...                      os.path.basename(d))
    ...             sys.stderr.flush()
    ...             sys.stdout.flush()
    ...             raise
    ...
    ...         return paths
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

And put back the typo::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bin
    ... """)

When we rerun the buildout::

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    data-dir: Removed foo due to error
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

we get the same error, but we don't get the directory left behind::

    >>> os.path.exists('foo')
    False

It's critical that recipes clean up partial effects when errors
occur.  Because recipes most commonly create files and directories,
buildout provides a helper API for removing created files when an
error occurs.  Option objects have a ``created`` method that can be called
to record files as they are created.  If the ``install`` or ``update`` method
returns with an error, then any registered paths are removed
automatically.  The method returns the files registered and can be
used to return the files created.  Let's use this API to simplify the
recipe::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         for path in paths:
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...             self.options.created(path)
    ...
    ...         return self.options.created()
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

We returned by calling ``created``, taking advantage of the fact that it
returns the registered paths.  We did this for illustrative purposes.
It would be simpler to just return the paths as before.

If we rerun the buildout again, we'll get the error and no
directories will be created::

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

    >>> os.path.exists('foo')
    False

Now, we'll fix the typo again and we'll get the directories we expect::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bins
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bins

    >>> os.path.exists('foo')
    True
    >>> os.path.exists('bins')
    True

Configuration file syntax
-------------------------

A buildout configuration file consists of a sequence of sections.  A
section has a *section header* followed by 0 or more *section options*.
(Buildout configuration files may be viewed as a variation on INI
files.)

A section header consists of a section name enclosed in square braces.
A section name consists of one or more non-whitespace characters other
than square braces (``[``, ``]``), curly braces (``{``, ``}``), colons (``:``)
or equal signs (``=``). Whitespace surrounding section names is ignored.

A section header can optionally have a condition expression separated
by a colon.  See `Conditional sections`_.

Options consist of option names, followed by optional space or tab
characters, an optional plus or minus sign and an equal sign and
values.  An option value may be spread over multiple lines as long as
the lines after the first start with a whitespace character.  An
option name consists of one or more non-whitespace characters other
than equal signs, square braces (``[``, ``]``), curly braces (``{``, ``}``),
plus signs or colons (``:``). The option name ``<`` is reserved.  An
option's data consists of the characters following the equal sign on
the start line, plus the continuation lines.

Option values have extra whitespace stripped.  How this is done
depends on whether the value has non-whitespace characters on the
first line.  If an option value has non-whitespace characters on the
first line, then each line is stripped and blank lines are removed.
For example, in::

  [foo]
  bar = 1
  baz = a
        b

        c

.. -> text

    >>> from io import StringIO
    >>> import pprint, zc.buildout.configparser
    >>> pprint.pprint(zc.buildout.configparser.parse(StringIO(
    ...     text), 'test'))
    {'foo': {'bar': '1', 'baz': 'a\nb\nc'}}

The value of of ``bar`` is ``'1'`` and the value of ``baz`` is
``'a\nb\nc'``.

If the first line of an option does **not** contain whitespace, then the
value is dedented (with ``textwrap.dedent``), trailing spaces in lines
are removed, and leading and trailing blank lines are removed.  For
example, in::


  [foo]
  bar =
  baz =

    a
      b

    c

.. -> text

    >>> pprint.pprint(zc.buildout.configparser.parse(StringIO(
    ...     text), 'test'))
    {'foo': {'bar': '', 'baz': 'a\n  b\n\nc'}}

The value of bar is ``''``, and the value of baz is ``'a\n  b\n\nc'``.

Lines starting with ``#`` or ``;`` characters are comments.  Comments can
also be placed after the closing square bracket (``]``) in a section header.

Buildout configuration data are Python strings, which are bytes in
Python 2 and unicode in Python 3.

Sections and options within sections may be repeated.  Multiple
occurrences of a section are treated as if they were concatenated.
The last option value for a given name in a section overrides previous
values.

In addition to the syntactic details above:

- option names are case sensitive

- option values can use a substitution syntax, described below, to
  refer to option values in specific sections.

- option values can be appended or removed using the - and +
  operators.

Annotated sections
------------------

When used with the ``annotate`` command, buildout displays annotated sections.
All sections are displayed, sorted alphabetically. For each section,
all key-value pairs are displayed, sorted alphabetically, along with
the origin of the value (file name or ``COMPUTED_VALUE``, ``DEFAULT_VALUE``,
``COMMAND_LINE_VALUE``)::

    >>> print_(system([buildout, 'annotate']), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [buildout]
    allow-hosts= *
        DEFAULT_VALUE
    allow-picked-versions= true
        DEFAULT_VALUE
    allow-unknown-extras= false
        DEFAULT_VALUE
    bin-directory= bin
        DEFAULT_VALUE
    develop= recipes
        buildout.cfg
    develop-eggs-directory= develop-eggs
        DEFAULT_VALUE
    directory= /sample-buildout
        COMPUTED_VALUE
    eggs-directory= /sample-buildout/eggs
        DEFAULT_VALUE
    executable= ...
        DEFAULT_VALUE
    find-links=
        DEFAULT_VALUE
    install-from-cache= false
        DEFAULT_VALUE
    installed= .installed.cfg
        DEFAULT_VALUE
    log-format=
        DEFAULT_VALUE
    log-level= INFO
        DEFAULT_VALUE
    newest= true
        DEFAULT_VALUE
    offline= false
        DEFAULT_VALUE
    parts= data-dir
        buildout.cfg
    parts-directory= parts
        DEFAULT_VALUE
    prefer-final= true
        DEFAULT_VALUE
    python= buildout
        DEFAULT_VALUE
    show-picked-versions= false
        DEFAULT_VALUE
    socket-timeout=
        DEFAULT_VALUE
    update-versions-file=
        DEFAULT_VALUE
    use-dependency-links= true
        DEFAULT_VALUE
    versions= versions
        DEFAULT_VALUE
    <BLANKLINE>
    [data-dir]
    path= foo bins
        buildout.cfg
    recipe= recipes:mkdir
        buildout.cfg
    <BLANKLINE>
    [versions]
    zc.buildout = >=1.99
        DEFAULT_VALUE
    zc.recipe.egg = >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

The ``annotate`` command is sensitive to the verbosity flag.
You get more information about the way values are computed::

    >>> print_(system([buildout, '-v', 'annotate']), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [buildout]
    allow-hosts= *
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = *
    <BLANKLINE>
    allow-picked-versions= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    allow-unknown-extras= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    bin-directory= bin
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = bin
    <BLANKLINE>
    develop= recipes
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = recipes
    <BLANKLINE>
    develop-eggs-directory= develop-eggs
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = develop-eggs
    <BLANKLINE>
    directory= /sample-buildout
    <BLANKLINE>
       AS COMPUTED_VALUE
       SET VALUE = /sample-buildout
    <BLANKLINE>
    eggs-directory= /sample-buildout/eggs
    <BLANKLINE>
       AS DEFAULT_VALUE
       DIRECTORY VALUE = /sample-buildout/eggs
       AS DEFAULT_VALUE
       SET VALUE = eggs
    <BLANKLINE>
    executable= ...
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = ...
    <BLANKLINE>
    find-links=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    install-from-cache= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    installed= .installed.cfg
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = .installed.cfg
    <BLANKLINE>
    log-format=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    log-level= INFO
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = INFO
    <BLANKLINE>
    newest= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    offline= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    parts= data-dir
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = data-dir
    <BLANKLINE>
    parts-directory= parts
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = parts
    <BLANKLINE>
    prefer-final= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    python= buildout
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = buildout
    <BLANKLINE>
    show-picked-versions= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    socket-timeout=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    update-versions-file=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    use-dependency-links= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    verbosity= 10
    <BLANKLINE>
       AS COMMAND_LINE_VALUE
       SET VALUE = 10
    <BLANKLINE>
    versions= versions
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = versions
    <BLANKLINE>
    <BLANKLINE>
    [data-dir]
    path= foo bins
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = foo bins
    <BLANKLINE>
    recipe= recipes:mkdir
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = recipes:mkdir
    <BLANKLINE>
    <BLANKLINE>
    [versions]
    ...

The output of the ``annotate`` command can be very long.
You can restrict the output to some sections by passing section names as arguments::

    >>> print_(system([buildout, 'annotate', 'versions']), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [versions]
    zc.buildout= >=1.99
        DEFAULT_VALUE
    zc.recipe.egg= >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

Query values
------------

For continuous integration, it might be useful to query the buildout config.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = .
    ...
    ... [values]
    ... host = buildout.org
    ... multiline =
    ...   first
    ...   second
    ... """)

    >>> print_(system([buildout, 'query', 'buildout:develop']), end='')
    .

    >>> print_(system([buildout, 'query', 'values:host']), end='')
    buildout.org

    >>> print_(system([buildout, 'query', 'values:multiline']), end='')
    first
    second

As with assignments, if the section is omitted, 'buildout' section is assumed.

    >>> print_(system([buildout, 'query', 'develop']), end='')
    .

When used with -v option, the query command also displays section and key.

    >>> print_(system([buildout, '-v', 'query', 'develop']), end='')
    ${buildout:develop}
    .

    >>> print_(system([buildout, '-v', 'query', 'values:host']), end='')
    ${values:host}
    buildout.org

The query commands outputs proper error messages.

    >>> print_(system([buildout, 'query', 'versions', 'parts']), end='')
    Error: The query command requires a single argument.

    >>> print_(system([buildout, 'query']), end='')
    Error: The query command requires a single argument.

    >>> print_(system([buildout, 'query', 'invalid:section:key']), end='')
    Error: Invalid option: invalid:section:key

    >>> print_(system([buildout, '-v', 'query', 'values:port']), end='')
    ${values:port}
    Error: Key not found: port

    >>> print_(system([buildout, '-v', 'query', 'versionx']), end='')
    ${buildout:versionx}
    Error: Key not found: versionx

    >>> print_(system([buildout, '-v', 'query', 'specific:port']), end='')
    ${specific:port}
    Error: Section not found: specific

Variable substitutions
----------------------

Buildout configuration files support variable substitution.
To illustrate this, we'll create an debug recipe to
allow us to see interactions with the buildout::

    >>> write(sample_buildout, 'recipes', 'debug.py',
    ... """
    ... import sys
    ... class Debug:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         for option, value in sorted(self.options.items()):
    ...             sys.stdout.write('%s %s\\n' % (option, value))
    ...         return ()
    ...
    ...     update = install
    ... """)

    >>> write(sample_buildout, 'recipes', 'environ.py',
    ... """
    ... import sys
    ... import os
    ... class Environ:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.options = options
    ...
    ...     def install(self):
    ...         _ = self.options['name']
    ...         sys.stdout.write('HOME %s\\n' % os.environ['HOME'])
    ...         sys.stdout.write('USERPROFILE %s\\n' % os.environ['USERPROFILE'])
    ...         sys.stdout.write('expanduser %s\\n' % os.path.expanduser('~'))
    ...         return ()
    ...
    ...     update = install
    ... """)

This recipe doesn't actually create anything. The install method
doesn't return anything, because it didn't create any files or
directories.

We also have to update our setup script::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... environ = environ:Environ
    ... ''')
    ... setup(name="recipes", entry_points=entry_points, py_modules=['debug', 'environ'])
    ... """)

We've rearranged the script a bit to make the entry points easier to
edit.  Specifically, entry points are now defined as a configuration
string, rather than a dictionary.

Let's update our configuration to provide variable substitution
examples::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

We used a string-template substitution for ``File-1`` and ``File-2``.  This
type of substitution uses the ``string.Template`` syntax.  Names
substituted are qualified option names, consisting of a section name
and option name joined by a colon.

Now, if we run the buildout, we'll see the options with the values
substituted::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

Note that the substitution of the ``data-dir`` path option reflects the
update to the option performed by the ``mkdir`` recipe.

It might seem surprising that ``mydata`` was created again.  This is
because we changed our ``recipes`` package by adding the ``debug`` module.
The buildout system didn't know if this module could affect the ``mkdir``
recipe, so it assumed it could and reinstalled ``mydata``.  If we rerun
the buildout::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating data-dir.
    Updating debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

we can see that ``mydata`` was not recreated.

Note that, in this case, we didn't specify a log level, so
we didn't get output about what the buildout was doing.

Section and option names in variable substitutions are only allowed to
contain alphanumeric characters, hyphens, periods and spaces. This
restriction might be relaxed in future releases.

We can omit the section name in a variable substitution to refer to
the current section.  We can also use the special option,
``_buildout_section_name_`` to get the current section name::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${:File-1}/log
    ... my_name = ${:_buildout_section_name_}
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Updating data-dir.
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    my_name debug
    recipe recipes:debug

Automatic part selection and ordering
-------------------------------------

When a section with a recipe is referred to, either through variable
substitution or by an initializing recipe, the section is treated as a
part and added to the part list before the referencing part.  For
example, we can leave ``data-dir`` out of the parts list::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)


It will still be treated as a part::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Updating data-dir.
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

    >>> cat('.installed.cfg') # doctest: +ELLIPSIS
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir debug
    ...

Note that the ``data-dir`` part is included *before* the ``debug`` part,
because the ``debug`` part refers to the ``data-dir`` part.  Even if we list
the ``data-dir`` part after the ``debug`` part, it will be included before::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug data-dir
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)


It will still be treated as a part::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating data-dir.
    Updating debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

    >>> cat('.installed.cfg') # doctest: +ELLIPSIS
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir debug
    ...

Extending sections (macros)
---------------------------

A section (other than the buildout section) can extend one or more
other sections using the ``<`` option.  Options from the referenced
sections are copied to the referring section *before* variable
substitution.  This, together with the ability to refer to variables
of the current section, allows sections to be used as macros::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = myfiles
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ...
    ... [with_file1]
    ... <= debug
    ... file1 = ${:path}/file1
    ... color = red
    ...
    ... [with_file2]
    ... <= debug
    ... file2 = ${:path}/file2
    ... color = blue
    ...
    ... [myfiles]
    ... <= with_file1
    ...    with_file2
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Uninstalling data-dir.
    Installing myfiles.
    color blue
    file1 mydata/file1
    file2 mydata/file2
    path mydata
    recipe recipes:debug

In this example, the ``debug``, ``with_file1`` and ``with_file2`` sections act
as macros. In particular, the variable substitutions are performed
relative to the ``myfiles`` section.

.. note:: Don't be fooled by the appearance of the ``<= section`` lines ---
    though ``<=`` may look like a new operator, it's still just the familiar
    ``key = value`` syntax.

.. cleanup buildout

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... """)

    >>> _ = system(buildout)

Extending sections (macros) - Adding and removing options
---------------------------------------------------------

We can also add and remove options in extended sections.

This is illustrated below; first we define a base configuration.

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... parts = part1 part2 part3
    ...
    ... [part1]
    ... recipe =
    ... option = a1
    ...          a2
    ...
    ... [part2]
    ... <= part1
    ... option -= a1
    ... option += c3 c4
    ...
    ... [part3]
    ... <= part2
    ... option += d2
    ...            c5 d1 d6
    ... option -= a2
    ... """)

To verify that the options are adjusted correctly, we'll set up an
extension that prints out the options.

    >>> mkdir(sample_buildout, 'demo')
    >>> write(sample_buildout, 'demo', 'demo.py',
    ... """
    ... import sys
    ... def ext(buildout):
    ...     sys.stdout.write(str(
    ...         [part['option'] for name, part in sorted(buildout.items())
    ...          if name.startswith('part')])+'\\n')
    ... """)

    >>> write(sample_buildout, 'demo', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name="demo",
    ...     entry_points={'zc.buildout.extension': ['ext = demo:ext']},
    ...     )
    ... """)

Set up a buildout configuration for this extension.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... parts =
    ... """)

    >>> os.chdir(sample_buildout)
    >>> print_(system(os.path.join(sample_buildout, 'bin', 'buildout')), end='') # doctest: +ELLIPSIS
    Develop: '/sample-buildout/demo'

Verify option values.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... extensions = demo
    ... extends = base.cfg
    ... """)

    >>> print_(system(os.path.join('bin', 'buildout')), end='')
    ['a1/na2', 'a2/nc3 c4', 'c3 c4/nd2/nc5 d1 d6']
    Develop: '/sample-buildout/demo'

Cleanup.

    >>> os.remove(os.path.join(sample_buildout, 'base.cfg'))
    >>> rmdir(sample_buildout, 'demo')
