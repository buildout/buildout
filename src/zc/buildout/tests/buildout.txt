Buildouts
=========

The word "buildout" refers to a description of a set of parts and the
software to create and assemble them.  It is often used informally to
refer to an installed system based on a buildout definition.  For
example, if we are creating an application named "Foo", then "the Foo
buildout" is the collection of configuration and application-specific
software that allows an instance of the application to be created.  We
may refer to such an instance of the application informally as "a Foo
buildout".

This document describes how to define buildouts using buildout
configuration files and recipes.  There are three ways to set up the
buildout software and create a buildout instance:

1. Install the ``zc.buildout`` egg with ``easy_install`` and use the buildout
   script installed in a Python scripts area.

2. Use the buildout bootstrap script to create a buildout that
   includes both the ``setuptools`` and ``zc.buildout`` eggs.  This allows you
   to use the buildout software without modifying a Python install.
   The buildout script is installed into your buildout local scripts
   area.

3. Use a buildout command from an already installed buildout to
   bootstrap a new buildout.  (See the section on bootstrapping later
   in this document.)

Often, a software project will be managed in a software repository,
such as a subversion repository, that includes some software source
directories, buildout configuration files, and a copy of the buildout
bootstrap script.  To work on the project, one would check out the
project from the repository and run the bootstrap script which
installs ``setuptools`` and ``zc.buildout`` into the checkout as well as any
parts defined.

We have a sample buildout that we created using the bootstrap command
of an existing buildout (method 3 above).  It has the absolute minimum
information.  We have ``bin``, ``develop-eggs``, ``eggs`` and ``parts``
directories, and a configuration file::

    >>> ls(sample_buildout)
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  parts

The ``bin`` directory contains scripts::

    >>> ls(sample_buildout, 'bin')
    -  buildout

The ``eggs`` directory has installed distributions:

    >>> ls(sample_buildout, 'eggs')
    -  pip.egg-link
    -  setuptools.egg-link
    -  wheel.egg-link
    -  zc.buildout.egg-link

The ``develop-eggs`` and ``parts`` directories are initially empty::

    >>> ls(sample_buildout, 'develop-eggs')
    >>> ls(sample_buildout, 'parts')

The ``develop-eggs`` directory holds egg links for software being
developed in the buildout.  We separate ``develop-eggs`` and other eggs to
allow eggs directories to be shared across multiple buildouts.  For
example, a common developer technique is to define a common eggs
directory in their home that all non-develop eggs are stored in.  This
allows larger buildouts to be set up much more quickly and saves disk
space.

The ``parts`` directory provides an area where recipes can install
part data.  For example, if we built a custom Python, we would
install it in the ``parts`` directory.  Part data is stored in a
sub-directory of the parts directory with the same name as the part.

Buildouts are defined using configuration files.  These are in the
format defined by the Python ``ConfigParser`` module, with extensions
that we'll describe later.  By default, when a buildout is run, it
looks for the file ``buildout.cfg`` in the directory where the buildout is
run.

The minimal configuration file has a ``buildout`` section that defines no
parts::

    >>> cat(sample_buildout, 'buildout.cfg')
    [buildout]
    parts =

A part is simply something to be created by a buildout.  It can be
almost anything, such as a Python package, a program, a directory, or
even a configuration file.

Recipes
-------

A part is created by a recipe.  Recipes are always installed as Python
eggs. They can be downloaded from a package server, such as the
Python Package Index, or they can be developed as part of a project
using a "develop" egg.

A develop egg is a special kind of egg that gets installed as an "egg
link" that contains the name of a source directory.  Develop eggs
don't have to be packaged for distribution to be used and can be
modified in place, which is especially useful while they are being
developed.

Let's create a recipe as part of the sample project.  We'll create a
recipe for creating directories.  First, we'll create a recipes source
directory for our local recipes::

    >>> mkdir(sample_buildout, 'recipes')

and then we'll create a source file for our ``mkdir`` recipe::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...         options['path'] = os.path.join(
    ...                               buildout['buildout']['directory'],
    ...                               options['path'],
    ...                               )
    ...         if not os.path.isdir(os.path.dirname(options['path'])):
    ...             logging.getLogger(self.name).error(
    ...                 'Cannot create %s. %s is not a directory.',
    ...                 options['path'], os.path.dirname(options['path']))
    ...             raise zc.buildout.UserError('Invalid Path')
    ...
    ...
    ...     def install(self):
    ...         path = self.options['path']
    ...         logging.getLogger(self.name).info(
    ...             'Creating directory %s', os.path.basename(path))
    ...         os.mkdir(path)
    ...         return path
    ...
    ...     def update(self):
    ...         pass
    ... """)

Currently, recipes must define 3 methods:

- a constructor,

- an install method, and

- an update method.

The constructor is responsible for updating a parts options to reflect
data read from other sections.  The buildout system keeps track of
whether a part specification has changed.  A part specification has
changed if it's options, after adjusting for data read from other
sections, has changed, or if the recipe has changed.  Only the options
for the part are considered.  If data are read from other sections,
then that information has to be reflected in the parts options.  In
the ``mkdir`` example, the given path is interpreted relative to the
buildout directory, and data from the buildout directory is read.  The
path option is updated to reflect this.  If the directory option was
changed in the buildout sections, we would know to update parts
created using the ``mkdir`` recipe using relative path names.

When buildout is run, it saves configuration data for installed parts
in a file named ``.installed.cfg``.  In subsequent runs, it compares
part-configuration data stored in the ``.installed.cfg`` file and the
part-configuration data loaded from the configuration files as
modified by recipe constructors to decide if the configuration of a
part has changed. If the configuration has changed, or if the recipe
has changed, then the part is uninstalled and reinstalled.  The
buildout only looks at the part's options, so any data used to
configure the part needs to be reflected in the part's options.  It is
the job of a recipe constructor to make sure that the options include
all relevant data.

Of course, parts are also uninstalled if they are no longer used.

The recipe defines a constructor that takes a buildout object, a part
name, and an options dictionary. It saves them in instance attributes.
If the path is relative, we'll interpret it as relative to the
buildout directory.  The buildout object passed in is a mapping from
section name to a mapping of options for that section. The buildout
directory is available as the directory option of the buildout
section.  We normalize the path and save it back into the options
directory.

The install method is responsible for creating the part.  In this
case, we need the path of the directory to create.  We'll use a path
option from our options dictionary.  The install method logs what it's
doing using the Python ``logging`` call.  We return the path that we
installed.  If the part is uninstalled or reinstalled, then the path
returned will be removed by the buildout machinery.  A recipe install
method is expected to return a string, or an iterable of strings
containing paths to be removed if a part is uninstalled.  For most
recipes, this is all of the uninstall support needed. For more complex
uninstallation scenarios, use `Uninstall recipes`_.

The update method is responsible for updating an already installed
part.  An empty method is often provided, as in this example, if parts
can't be updated.  An update method can return None, a string, or an
iterable of strings.  If a string or iterable of strings is returned,
then the saved list of paths to be uninstalled is updated with the new
information by adding any new files returned by the update method.

We need to provide packaging information so that our recipe can be
installed as a develop egg. The minimum information we need to specify
is a name.  For recipes, we also need to define the
names of the recipe classes as entry points.  Packaging information is
provided via a ``setup.py`` script::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name = "recipes",
    ...     entry_points = {'zc.buildout': ['mkdir = mkdir:Mkdir']},
    ...     )
    ... """)

Our setup script defines an *entry point*. Entry points provide
a way for an egg to define the services it provides.  Here we've said
that we define a ``zc.buildout`` entry point named ``mkdir``.  Recipe
classes must be exposed as entry points in the ``zc.buildout`` group.  We
give entry points names within the group.

We also need a ``README.txt`` for our recipes to avoid an annoying warning
from ``distutils`` (which ``setuptools`` and ``zc.buildout`` are based on)::

    >>> write(sample_buildout, 'recipes', 'README.txt', " ")

Now let's update our ``buildout.cfg``::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mystuff
    ... """)

Let's go through the changes one by one::

    develop = recipes

This tells the buildout to install a development egg for our recipes.
Any number of paths can be listed.  The paths can be relative or
absolute.  If relative, they are treated as relative to the buildout
directory.  They can be directory or file paths.  If a file path is
given, it should point to a Python setup script.  If a directory path
is given, it should point to a directory containing a ``setup.py`` file.
Development eggs are installed before building any parts, as they may
provide locally-defined recipes needed by the parts.

::

    parts = data-dir

Here we've named a part to be "built".  We can use any name we want,
except that part names have to be unique and recipes will often
use the part name to decide what to do.

::

    [data-dir]
    recipe = recipes:mkdir
    path = mystuff


When we name a part, we also create a section of the same
name that contains part data.  In this section, we'll define
the recipe to be used to install the part.  In this case, we also
specify the path to be created.

Let's run the buildout.  We do so by running the build script in the
buildout::

    >>> import os
    >>> os.chdir(sample_buildout)
    >>> buildout = os.path.join(sample_buildout, 'bin', 'buildout')
    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory mystuff

We see that the recipe created the directory, as expected::

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  mystuff
    d  parts
    d  recipes

In addition, .installed.cfg has been created containing information
about the part we installed::

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir
    <BLANKLINE>
    [data-dir]
    __buildout_installed__ = /sample-buildout/mystuff
    __buildout_signature__ = recipes-c7vHV6ekIDUPy/7fjAaYjg==
    path = /sample-buildout/mystuff
    recipe = recipes:mkdir

Note that the directory we installed is included in .installed.cfg.
In addition, the path option includes the actual destination
directory.

If we change the name of the directory in the configuration file,
we'll see that the directory gets removed and recreated::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  develop-eggs
    d  eggs
    d  mydata
    d  parts
    d  recipes

If any of the files or directories created by a recipe are removed,
the part will be reinstalled::

    >>> rmdir(sample_buildout, 'mydata')
    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata

Error reporting
---------------

If a user makes an error the error needs to be reported, and work needs
to stop.  This is accomplished by logging a detailed error message and
then raising a
``zc.buildout.UserError`` exception (or a subclass of this exception).
Raising an error other than a
``UserError`` still displays the error, but labels it as a bug in the
buildout software or recipe. In the sample above, if someone gives a
non-existent directory to create the directory in::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = /xxx/mydata
    ... """)

we'll get a user error, not a traceback::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    data-dir: Cannot create .../xxx/mydata. .../xxx is not a directory.
    While:
      Installing.
      Getting section data-dir.
      Initializing section data-dir.
    Error: Invalid Path


Recipe Error Handling
---------------------

If an error occurs during installation, it is up to the recipe to
clean up any system side effects, such as files created.  Let's update
the ``mkdir`` recipe to support multiple paths::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         for path in paths:
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...         return paths
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

If there is an error creating a path, the install method will exit and
leave previously created paths in place::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bin
    ... """)

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

We meant to create a directory ``bins``, but typed ``bin``.  Now ``foo`` was
left behind::

    >>> os.path.exists('foo')
    True

If we fix the typo::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bins
    ... """)

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

Now they fail because ``foo`` exists, because it was left behind::

    >>> remove('foo')

Let's fix the recipe::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout, sys
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         created = []
    ...         try:
    ...             for path in paths:
    ...                 logging.getLogger(self.name).info(
    ...                     'Creating directory %s', os.path.basename(path))
    ...                 os.mkdir(path)
    ...                 created.append(path)
    ...         except Exception:
    ...             for d in created:
    ...                 os.rmdir(d)
    ...                 assert not os.path.exists(d)
    ...                 logging.getLogger(self.name).info(
    ...                     'Removed %s due to error',
    ...                      os.path.basename(d))
    ...             sys.stderr.flush()
    ...             sys.stdout.flush()
    ...             raise
    ...
    ...         return paths
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

And put back the typo::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bin
    ... """)

When we rerun the buildout::

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    data-dir: Removed foo due to error
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

we get the same error, but we don't get the directory left behind::

    >>> os.path.exists('foo')
    False

It's critical that recipes clean up partial effects when errors
occur.  Because recipes most commonly create files and directories,
buildout provides a helper API for removing created files when an
error occurs.  Option objects have a ``created`` method that can be called
to record files as they are created.  If the ``install`` or ``update`` method
returns with an error, then any registered paths are removed
automatically.  The method returns the files registered and can be
used to return the files created.  Let's use this API to simplify the
recipe::

    >>> write(sample_buildout, 'recipes', 'mkdir.py',
    ... """
    ... import logging, os, zc.buildout
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.name, self.options = name, options
    ...
    ...         # Normalize paths and check that their parent
    ...         # directories exist:
    ...         paths = []
    ...         for path in options['path'].split():
    ...             path = os.path.join(buildout['buildout']['directory'], path)
    ...             if not os.path.isdir(os.path.dirname(path)):
    ...                 logging.getLogger(self.name).error(
    ...                     'Cannot create %s. %s is not a directory.',
    ...                     options['path'], os.path.dirname(options['path']))
    ...                 raise zc.buildout.UserError('Invalid Path')
    ...             paths.append(path)
    ...         options['path'] = ' '.join(paths)
    ...
    ...     def install(self):
    ...         paths = self.options['path'].split()
    ...         for path in paths:
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...             self.options.created(path)
    ...
    ...         return self.options.created()
    ...
    ...     def update(self):
    ...         pass
    ... """)

..

    >>> clean_up_pyc(sample_buildout, 'recipes', 'mkdir.py')

We returned by calling ``created``, taking advantage of the fact that it
returns the registered paths.  We did this for illustrative purposes.
It would be simpler to just return the paths as before.

If we rerun the buildout again, we'll get the error and no
directories will be created::

    >>> print_(system(buildout)) # doctest: +ELLIPSIS
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bin
    While:
      Installing data-dir.
    <BLANKLINE>
    An internal error occurred due to a bug in either zc.buildout or in a
    recipe being used:
    Traceback (most recent call last):
    ... exists...

    >>> os.path.exists('foo')
    False

Now, we'll fix the typo again and we'll get the directories we expect::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = foo bins
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing data-dir.
    data-dir: Creating directory foo
    data-dir: Creating directory bins

    >>> os.path.exists('foo')
    True
    >>> os.path.exists('bins')
    True

Configuration file syntax
-------------------------

A buildout configuration file consists of a sequence of sections.  A
section has a *section header* followed by 0 or more *section options*.
(Buildout configuration files may be viewed as a variation on INI
files.)

A section header consists of a section name enclosed in square braces.
A section name consists of one or more non-whitespace characters other
than square braces (``[``, ``]``), curly braces (``{``, ``}``), colons (``:``)
or equal signs (``=``). Whitespace surrounding section names is ignored.

A section header can optionally have a condition expression separated
by a colon.  See `Conditional sections`_.

Options consist of option names, followed by optional space or tab
characters, an optional plus or minus sign and an equal sign and
values.  An option value may be spread over multiple lines as long as
the lines after the first start with a whitespace character.  An
option name consists of one or more non-whitespace characters other
than equal signs, square braces (``[``, ``]``), curly braces (``{``, ``}``),
plus signs or colons (``:``). The option name ``<`` is reserved.  An
option's data consists of the characters following the equal sign on
the start line, plus the continuation lines.

Option values have extra whitespace stripped.  How this is done
depends on whether the value has non-whitespace characters on the
first line.  If an option value has non-whitespace characters on the
first line, then each line is stripped and blank lines are removed.
For example, in::

  [foo]
  bar = 1
  baz = a
        b

        c

.. -> text

    >>> try: import StringIO
    ... except ImportError: import io as StringIO
    >>> import pprint, zc.buildout.configparser
    >>> pprint.pprint(zc.buildout.configparser.parse(StringIO.StringIO(
    ...     text), 'test'))
    {'foo': {'bar': '1', 'baz': 'a\nb\nc'}}

The value of of ``bar`` is ``'1'`` and the value of ``baz`` is
``'a\nb\nc'``.

If the first line of an option does **not** contain whitespace, then the
value is dedented (with ``textwrap.dedent``), trailing spaces in lines
are removed, and leading and trailing blank lines are removed.  For
example, in::


  [foo]
  bar =
  baz =

    a
      b

    c

.. -> text

    >>> pprint.pprint(zc.buildout.configparser.parse(StringIO.StringIO(
    ...     text), 'test'))
    {'foo': {'bar': '', 'baz': 'a\n  b\n\nc'}}

The value of bar is ``''``, and the value of baz is ``'a\n  b\n\nc'``.

Lines starting with ``#`` or ``;`` characters are comments.  Comments can
also be placed after the closing square bracket (``]``) in a section header.

Buildout configuration data are Python strings, which are bytes in
Python 2 and unicode in Python 3.

Sections and options within sections may be repeated.  Multiple
occurrences of a section are treated as if they were concatenated.
The last option value for a given name in a section overrides previous
values.

In addition to the syntactic details above:

- option names are case sensitive

- option values can use a substitution syntax, described below, to
  refer to option values in specific sections.

- option values can be appended or removed using the - and +
  operators.

Annotated sections
------------------

When used with the ``annotate`` command, buildout displays annotated sections.
All sections are displayed, sorted alphabetically. For each section,
all key-value pairs are displayed, sorted alphabetically, along with
the origin of the value (file name or ``COMPUTED_VALUE``, ``DEFAULT_VALUE``,
``COMMAND_LINE_VALUE``)::

    >>> print_(system(buildout+ ' annotate'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [buildout]
    allow-hosts= *
        DEFAULT_VALUE
    allow-picked-versions= true
        DEFAULT_VALUE
    allow-unknown-extras= false
        DEFAULT_VALUE
    bin-directory= bin
        DEFAULT_VALUE
    develop= recipes
        buildout.cfg
    develop-eggs-directory= develop-eggs
        DEFAULT_VALUE
    directory= /sample-buildout
        COMPUTED_VALUE
    eggs-directory= /sample-buildout/eggs
        DEFAULT_VALUE
    executable= ...
        DEFAULT_VALUE
    find-links=
        DEFAULT_VALUE
    install-from-cache= false
        DEFAULT_VALUE
    installed= .installed.cfg
        DEFAULT_VALUE
    log-format=
        DEFAULT_VALUE
    log-level= INFO
        DEFAULT_VALUE
    newest= true
        DEFAULT_VALUE
    offline= false
        DEFAULT_VALUE
    parts= data-dir
        buildout.cfg
    parts-directory= parts
        DEFAULT_VALUE
    prefer-final= true
        DEFAULT_VALUE
    python= buildout
        DEFAULT_VALUE
    show-picked-versions= false
        DEFAULT_VALUE
    socket-timeout=
        DEFAULT_VALUE
    update-versions-file=
        DEFAULT_VALUE
    use-dependency-links= true
        DEFAULT_VALUE
    versions= versions
        DEFAULT_VALUE
    <BLANKLINE>
    [data-dir]
    path= foo bins
        buildout.cfg
    recipe= recipes:mkdir
        buildout.cfg
    <BLANKLINE>
    [versions]
    zc.buildout = >=1.99
        DEFAULT_VALUE
    zc.recipe.egg = >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

The ``annotate`` command is sensitive to the verbosity flag.
You get more information about the way values are computed::

    >>> print_(system(buildout+ ' -v annotate'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [buildout]
    allow-hosts= *
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = *
    <BLANKLINE>
    allow-picked-versions= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    allow-unknown-extras= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    bin-directory= bin
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = bin
    <BLANKLINE>
    develop= recipes
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = recipes
    <BLANKLINE>
    develop-eggs-directory= develop-eggs
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = develop-eggs
    <BLANKLINE>
    directory= /sample-buildout
    <BLANKLINE>
       AS COMPUTED_VALUE
       SET VALUE = /sample-buildout
    <BLANKLINE>
    eggs-directory= /sample-buildout/eggs
    <BLANKLINE>
       AS DEFAULT_VALUE
       DIRECTORY VALUE = /sample-buildout/eggs
       AS DEFAULT_VALUE
       SET VALUE = eggs
    <BLANKLINE>
    executable= ...
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = ...
    <BLANKLINE>
    find-links=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    install-from-cache= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    installed= .installed.cfg
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = .installed.cfg
    <BLANKLINE>
    log-format=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    log-level= INFO
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = INFO
    <BLANKLINE>
    newest= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    offline= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    parts= data-dir
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = data-dir
    <BLANKLINE>
    parts-directory= parts
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = parts
    <BLANKLINE>
    prefer-final= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    python= buildout
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = buildout
    <BLANKLINE>
    show-picked-versions= false
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = false
    <BLANKLINE>
    socket-timeout=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    update-versions-file=
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE =
    <BLANKLINE>
    use-dependency-links= true
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = true
    <BLANKLINE>
    verbosity= 10
    <BLANKLINE>
       AS COMMAND_LINE_VALUE
       SET VALUE = 10
    <BLANKLINE>
    versions= versions
    <BLANKLINE>
       AS DEFAULT_VALUE
       SET VALUE = versions
    <BLANKLINE>
    <BLANKLINE>
    [data-dir]
    path= foo bins
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = foo bins
    <BLANKLINE>
    recipe= recipes:mkdir
    <BLANKLINE>
       IN buildout.cfg
       SET VALUE = recipes:mkdir
    <BLANKLINE>
    <BLANKLINE>
    [versions]
    ...

The output of the ``annotate`` command can be very long.
You can restrict the output to some sections by passing section names as arguments::

    >>> print_(system(buildout+ ' annotate versions'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    <BLANKLINE>
    [versions]
    zc.buildout= >=1.99
        DEFAULT_VALUE
    zc.recipe.egg= >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

Query values
------------

For continuous integration, it might be useful to query the buildout config.
    
    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = .
    ...
    ... [values]
    ... host = buildout.org
    ... multiline =
    ...   first
    ...   second
    ... """)

    >>> print_(system(buildout+ ' query buildout:develop'), end='')
    .
    
    >>> print_(system(buildout+ ' query values:host'), end='')
    buildout.org

    >>> print_(system(buildout+ ' query values:multiline'), end='')
    first
    second

As with assignments, if the section is omitted, 'buildout' section is assumed.

    >>> print_(system(buildout+ ' query develop'), end='')
    .

When used with -v option, the query command also displays section and key.
    
    >>> print_(system(buildout+ ' -v query develop'), end='')
    ${buildout:develop}
    .

    >>> print_(system(buildout+ ' -v query values:host'), end='')
    ${values:host}
    buildout.org

The query commands outputs proper error messages.
    
    >>> print_(system(buildout+ ' query versions parts'), end='')
    Error: The query command requires a single argument.
    
    >>> print_(system(buildout+ ' query'), end='')
    Error: The query command requires a single argument.
    
    >>> print_(system(buildout+ ' query invalid:section:key'), end='')
    Error: Invalid option: invalid:section:key
    
    >>> print_(system(buildout+ ' -v query values:port'), end='')
    ${values:port}
    Error: Key not found: port
    
    >>> print_(system(buildout+ ' -v query versionx'), end='')
    ${buildout:versionx}
    Error: Key not found: versionx
    
    >>> print_(system(buildout+ ' -v query specific:port'), end='')
    ${specific:port}
    Error: Section not found: specific

Variable substitutions
----------------------

Buildout configuration files support variable substitution.
To illustrate this, we'll create an debug recipe to
allow us to see interactions with the buildout::

    >>> write(sample_buildout, 'recipes', 'debug.py',
    ... """
    ... import sys
    ... class Debug:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         for option, value in sorted(self.options.items()):
    ...             sys.stdout.write('%s %s\\n' % (option, value))
    ...         return ()
    ...
    ...     update = install
    ... """)

    >>> write(sample_buildout, 'recipes', 'environ.py',
    ... """
    ... import sys
    ... import os
    ... class Environ:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.options = options
    ...
    ...     def install(self):
    ...         _ = self.options['name']
    ...         sys.stdout.write('HOME %s\\n' % os.environ['HOME'])
    ...         sys.stdout.write('USERPROFILE %s\\n' % os.environ['USERPROFILE'])
    ...         sys.stdout.write('expanduser %s\\n' % os.path.expanduser('~'))
    ...         return ()
    ...
    ...     update = install
    ... """)

This recipe doesn't actually create anything. The install method
doesn't return anything, because it didn't create any files or
directories.

We also have to update our setup script::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... environ = environ:Environ
    ... ''')
    ... setup(name="recipes", entry_points=entry_points, py_modules=['debug', 'environ'])
    ... """)

We've rearranged the script a bit to make the entry points easier to
edit.  Specifically, entry points are now defined as a configuration
string, rather than a dictionary.

Let's update our configuration to provide variable substitution
examples::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

We used a string-template substitution for ``File-1`` and ``File-2``.  This
type of substitution uses the ``string.Template`` syntax.  Names
substituted are qualified option names, consisting of a section name
and option name joined by a colon.

Now, if we run the buildout, we'll see the options with the values
substituted::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling data-dir.
    Installing data-dir.
    data-dir: Creating directory mydata
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

Note that the substitution of the ``data-dir`` path option reflects the
update to the option performed by the ``mkdir`` recipe.

It might seem surprising that ``mydata`` was created again.  This is
because we changed our ``recipes`` package by adding the ``debug`` module.
The buildout system didn't know if this module could affect the ``mkdir``
recipe, so it assumed it could and reinstalled ``mydata``.  If we rerun
the buildout::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating data-dir.
    Updating debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

we can see that ``mydata`` was not recreated.

Note that, in this case, we didn't specify a log level, so
we didn't get output about what the buildout was doing.

Section and option names in variable substitutions are only allowed to
contain alphanumeric characters, hyphens, periods and spaces. This
restriction might be relaxed in future releases.

We can omit the section name in a variable substitution to refer to
the current section.  We can also use the special option,
``_buildout_section_name_`` to get the current section name::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data-dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${:File-1}/log
    ... my_name = ${:_buildout_section_name_}
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Updating data-dir.
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    my_name debug
    recipe recipes:debug

Automatic part selection and ordering
-------------------------------------

When a section with a recipe is referred to, either through variable
substitution or by an initializing recipe, the section is treated as a
part and added to the part list before the referencing part.  For
example, we can leave ``data-dir`` out of the parts list::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)


It will still be treated as a part::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Updating data-dir.
    Installing debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

    >>> cat('.installed.cfg') # doctest: +ELLIPSIS
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir debug
    ...

Note that the ``data-dir`` part is included *before* the ``debug`` part,
because the ``debug`` part refers to the ``data-dir`` part.  Even if we list
the ``data-dir`` part after the ``debug`` part, it will be included before::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug data-dir
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... File-1 = ${data-dir:path}/file
    ... File-2 = ${debug:File-1}/log
    ...
    ... [data-dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)


It will still be treated as a part::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating data-dir.
    Updating debug.
    File-1 /sample-buildout/mydata/file
    File-2 /sample-buildout/mydata/file/log
    recipe recipes:debug

    >>> cat('.installed.cfg') # doctest: +ELLIPSIS
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = data-dir debug
    ...

Extending sections (macros)
---------------------------

A section (other than the buildout section) can extend one or more
other sections using the ``<`` option.  Options from the referenced
sections are copied to the referring section *before* variable
substitution.  This, together with the ability to refer to variables
of the current section, allows sections to be used as macros::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = myfiles
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ...
    ... [with_file1]
    ... <= debug
    ... file1 = ${:path}/file1
    ... color = red
    ...
    ... [with_file2]
    ... <= debug
    ... file2 = ${:path}/file2
    ... color = blue
    ...
    ... [myfiles]
    ... <= with_file1
    ...    with_file2
    ... path = mydata
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Uninstalling data-dir.
    Installing myfiles.
    color blue
    file1 mydata/file1
    file2 mydata/file2
    path mydata
    recipe recipes:debug

In this example, the ``debug``, ``with_file1`` and ``with_file2`` sections act
as macros. In particular, the variable substitutions are performed
relative to the ``myfiles`` section.

.. note:: Don't be fooled by the appearance of the ``<= section`` lines ---
    though ``<=`` may look like a new operator, it's still just the familiar
    ``key = value`` syntax.

.. cleanup buildout

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... """)

    >>> _ = system(buildout)

Extending sections (macros) - Adding and removing options
---------------------------------------------------------

We can also add and remove options in extended sections.

This is illustrated below; first we define a base configuration.

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... parts = part1 part2 part3
    ...
    ... [part1]
    ... recipe =
    ... option = a1
    ...          a2
    ...
    ... [part2]
    ... <= part1
    ... option -= a1
    ... option += c3 c4
    ...
    ... [part3]
    ... <= part2
    ... option += d2
    ...            c5 d1 d6
    ... option -= a2
    ... """)

To verify that the options are adjusted correctly, we'll set up an
extension that prints out the options.

    >>> mkdir(sample_buildout, 'demo')
    >>> write(sample_buildout, 'demo', 'demo.py',
    ... """
    ... import sys
    ... def ext(buildout):
    ...     sys.stdout.write(str(
    ...         [part['option'] for name, part in sorted(buildout.items())
    ...          if name.startswith('part')])+'\\n')
    ... """)

    >>> write(sample_buildout, 'demo', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name="demo",
    ...     entry_points={'zc.buildout.extension': ['ext = demo:ext']},
    ...     )
    ... """)

Set up a buildout configuration for this extension.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... parts =
    ... """)

    >>> os.chdir(sample_buildout)
    >>> print_(system(os.path.join(sample_buildout, 'bin', 'buildout')), end='') # doctest: +ELLIPSIS
    Develop: '/sample-buildout/demo'

Verify option values.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... extensions = demo
    ... extends = base.cfg
    ... """)

    >>> print_(system(os.path.join('bin', 'buildout')), end='')
    ['a1/na2', 'a2/nc3 c4', 'c3 c4/nd2/nc5 d1 d6']
    Develop: '/sample-buildout/demo'

Cleanup.

    >>> os.remove(os.path.join(sample_buildout, 'base.cfg'))
    >>> rmdir(sample_buildout, 'demo')

Adding and removing options
---------------------------

We can append and remove values to an option by using the ``+`` and ``-``
operators.

This is illustrated below; first we define a base configuration::

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... parts = part1 part2 part3
    ...
    ... [part1]
    ... recipe =
    ... option = a1 a2
    ...
    ... [part2]
    ... recipe =
    ... option = b1 b2 b3 b4
    ...
    ... [part3]
    ... recipe =
    ... option = c1 c2
    ...
    ... [part4]
    ... recipe =
    ... option = d2
    ...     d3
    ...     d5
    ...
    ... """)

Extending this configuration, we can "adjust" the values set in the
base configuration file::

    >>> write(sample_buildout, 'extension1.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... # appending values
    ... [part1]
    ... option += a3 a4
    ...
    ... # removing values
    ... [part2]
    ... option -= b1 b2
    ...
    ... # alt. spelling
    ... [part3]
    ... option+=c3 c4 c5
    ...
    ... # combining both adding and removing
    ... [part4]
    ... option += d1
    ...      d4
    ... option -= d5
    ...
    ... # normal assignment
    ... [part5]
    ... option = h1 h2
    ...
    ... """)

An additional extension::

    >>> write(sample_buildout, 'extension2.cfg',
    ... """
    ... [buildout]
    ... extends = extension1.cfg
    ...
    ... # appending values
    ... [part1]
    ... option += a5
    ...
    ... # removing values
    ... [part2]
    ... option -= b1 b2 b3
    ...
    ... """)

To verify that the options are adjusted correctly, we'll set up an
extension that prints out the options::

    >>> mkdir(sample_buildout, 'demo')
    >>> write(sample_buildout, 'demo', 'demo.py',
    ... """
    ... import sys
    ... def ext(buildout):
    ...     sys.stdout.write(str(
    ...         [part['option'] for name, part in sorted(buildout.items())
    ...          if name.startswith('part')])+'\\n')
    ... """)

    >>> write(sample_buildout, 'demo', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name="demo",
    ...     entry_points={'zc.buildout.extension': ['ext = demo:ext']},
    ...     )
    ... """)

Set up a buildout configuration for this extension::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... parts =
    ... """)

    >>> os.chdir(sample_buildout)
    >>> print_(system(os.path.join(sample_buildout, 'bin', 'buildout')), end='')
    ... # doctest: +ELLIPSIS
    Develop: '/sample-buildout/demo'...

Verify option values::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... extensions = demo
    ... extends = extension2.cfg
    ... """)

    >>> print_(system(os.path.join('bin', 'buildout')), end='')
    ['a1 a2/na3 a4/na5', 'b1 b2 b3 b4', 'c1 c2/nc3 c4 c5', 'd2/nd3/nd1/nd4', 'h1 h2']
    Develop: '/sample-buildout/demo'

Annotated sections output shows which files are responsible for which
operations::

    >>> print_(system(os.path.join('bin', 'buildout') + ' annotate'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    ...
    <BLANKLINE>
    [part1]
    option= a1 a2
    a3 a4
    a5
        base.cfg
    +=  extension1.cfg
    +=  extension2.cfg
    recipe=
        base.cfg
    <BLANKLINE>
    [part2]
    option= b1 b2 b3 b4
        base.cfg
    -=  extension1.cfg
    -=  extension2.cfg
    recipe=
        base.cfg
    <BLANKLINE>
    [part3]
    option= c1 c2
    c3 c4 c5
        base.cfg
    +=  extension1.cfg
    recipe=
        base.cfg
    <BLANKLINE>
    [part4]
    option= d2
    d3
    d1
    d4
        base.cfg
    +=  extension1.cfg
    -=  extension1.cfg
    recipe=
        base.cfg
    <BLANKLINE>
    [part5]
    option= h1 h2
        extension1.cfg
    [versions]
    zc.buildout= >=1.99
        DEFAULT_VALUE
    zc.recipe.egg= >=1.99
        DEFAULT_VALUE
    <BLANKLINE>

With more verbosity::

    >>> print_(system(os.path.join('bin', 'buildout') + ' -v annotate'), end='')
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    <BLANKLINE>
    Annotated sections
    ==================
    ...
    [part1]
    option= a1 a2
    a3 a4
    a5
    <BLANKLINE>
       IN extension2.cfg
       ADD VALUE = a5
       IN extension1.cfg
       ADD VALUE = a3 a4
       IN base.cfg
       SET VALUE = a1 a2
    <BLANKLINE>
    ...
    [part2]
    option= b1 b2 b3 b4
    <BLANKLINE>
       IN extension2.cfg
       REMOVE VALUE = b1 b2 b3
       IN extension1.cfg
       REMOVE VALUE = b1 b2
       IN base.cfg
       SET VALUE = b1 b2 b3 b4
    <BLANKLINE>
    ...
    [part3]
    option=
       c1 c2
       c3 c4 c5
    <BLANKLINE>
       IN extension1.cfg
       ADD VALUE = c3 c4 c5
       IN base.cfg
       SET VALUE = c1 c2
    <BLANKLINE>
    ...
    [part4]
    option=
       d2
       d3
       d1
       d4
    <BLANKLINE>
       IN extension1.cfg
       REMOVE VALUE = d5
       IN extension1.cfg
       ADD VALUE =
          d1
          d4
       IN base.cfg
       SET VALUE =
          d2
          d3
          d5
    <BLANKLINE>
    ...
    [part5]
    option= h1 h2
    <BLANKLINE>
       IN extension1.cfg
       SET VALUE = h1 h2
    <BLANKLINE>
    ...

Cleanup::

    >>> os.remove(os.path.join(sample_buildout, 'base.cfg'))
    >>> os.remove(os.path.join(sample_buildout, 'extension1.cfg'))
    >>> os.remove(os.path.join(sample_buildout, 'extension2.cfg'))

Multiple configuration files
----------------------------

A configuration file can *extend* another configuration file.
Options are read from the other configuration file if they aren't
already defined by your configuration file.

The configuration files your file extends can extend
other configuration files.  The same file may be
used more than once although, of course, cycles aren't allowed.

To see how this works, we use an example::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op = buildout
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = base
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    op buildout
    recipe recipes:debug

The example is pretty trivial, but the pattern it illustrates is
pretty common.  In a more practical example, the base buildout might
represent a product and the extending buildout might be a
customization.

Here is a more elaborate example::

    >>> other = tmpdir('other')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = b1.cfg b2.cfg %(b3)s
    ...
    ... [debug]
    ... op = buildout
    ... """ % dict(b3=os.path.join(other, 'b3.cfg')))

    >>> write(sample_buildout, 'b1.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op1 = b1 1
    ... op2 = b1 2
    ... """)

    >>> write(sample_buildout, 'b2.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op2 = b2 2
    ... op3 = b2 3
    ... """)

    >>> write(other, 'b3.cfg',
    ... """
    ... [buildout]
    ... extends = b3base.cfg
    ...
    ... [debug]
    ... op4 = b3 4
    ... """)

    >>> write(other, 'b3base.cfg',
    ... """
    ... [debug]
    ... op5 = b3base 5
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = base
    ...
    ... [environ]
    ... recipe = recipes:environ
    ... name = base
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    recipe recipes:debug

There are several things to note about this example:

- We can name multiple files in an ``extends`` option.

- We can reference files recursively.

- Relative file names in extended options are interpreted relative to
  the directory containing the referencing configuration file.

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = b1.cfg
    ...
    ... [debug]
    ... op = buildout
    ... """)

    >>> print_(system(buildout + ' buildout:extends="b2.cfg"'), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    recipe recipes:debug

    >>> print_(system(buildout + ' buildout:extends="b2.cfg %(b3)s"'
    ... % dict(b3=os.path.join(other, 'b3.cfg'))), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    recipe recipes:debug

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = b1.cfg b2.cfg %(b3)s
    ...
    ... [debug]
    ... op = buildout
    ... """ % dict(b3=os.path.join(other, 'b3.cfg')))

Loading Configuration from URLs
-------------------------------

Configuration files can be loaded from URLs.  To see how this works,
we'll set up a web server with some configuration files::

    >>> server_data = tmpdir('server_data')

    >>> write(server_data, "r1.cfg",
    ... """
    ... [debug]
    ... op1 = r1 1
    ... op2 = r1 2
    ... """)

    >>> write(server_data, "r2.cfg",
    ... """
    ... [buildout]
    ... extends = r1.cfg
    ...
    ... [debug]
    ... op2 = r2 2
    ... op3 = r2 3
    ... """)

    >>> server_url = start_server(server_data)

    >>> write('client.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... extends = %(url)s/r2.cfg
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = base
    ... """ % dict(url=server_url))

    >>> print_(system(buildout+ ' -c client.cfg'), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op1 r1 1
    op2 r2 2
    op3 r2 3
    recipe recipes:debug

Here we specified a URL for the file we extended.  The file we
downloaded itself referred to a file on the server using a relative
URL reference.  Relative references are interpreted relative to the
base URL when they appear in configuration files loaded via URL.

We can also specify a URL as the configuration file to be used by a
buildout::

    >>> os.remove('client.cfg')
    >>> write(server_data, 'remote.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... extends = r2.cfg
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = remote
    ... """)

    >>> print_(system(buildout + ' -c ' + server_url + '/remote.cfg'), end='')
    While:
      Initializing.
    Error: Missing option: buildout:directory

Normally, the buildout directory defaults to a directory
containing a configuration file.  This won't work for configuration
files loaded from URLs.  In this case, the buildout directory would
normally be defined on the command line::

    >>> print_(system(buildout
    ...              + ' -c ' + server_url + '/remote.cfg'
    ...              + ' buildout:directory=' + sample_buildout
    ...              ), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name remote
    op1 r1 1
    op2 r2 2
    op3 r2 3
    recipe recipes:debug

User defaults
-------------

If the file ``$HOME/.buildout/default.cfg`` exists, it is read before
reading the configuration file.  (``$HOME`` is the value of the ``HOME``
environment variable. The ``/`` is replaced by the operating system file
delimiter.)::

    >>> home = tmpdir('home')
    >>> mkdir(home, '.buildout')
    >>> default_cfg = join(home, '.buildout', 'default.cfg')
    >>> write(default_cfg,
    ... """
    ... [debug]
    ... op1 = 1
    ... op7 = 7
    ... """)

    >>> env = dict(HOME=home, USERPROFILE=home)
    >>> print_(system(buildout, env=env), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    op7 7
    recipe recipes:debug

A buildout command-line argument, ``-U``, can be used to suppress reading
user defaults::

    >>> print_(system(buildout + ' -U', env=env), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    recipe recipes:debug

If the environment variable ``BUILDOUT_HOME`` is non-empty, that is used to
locate ``default.cfg`` instead of looking in ``~/.buildout/``.  Let's set up a
configuration file in an alternate directory and verify that we get the
appropriate set of defaults::

    >>> alterhome = tmpdir('alterhome')
    >>> write(alterhome, 'default.cfg',
    ... """
    ... [debug]
    ... op1 = 1'
    ... op7 = 7'
    ... op8 = eight!
    ... """)

    >>> env['BUILDOUT_HOME'] = alterhome
    >>> print_(system(buildout, env=env), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    op7 7'
    op8 eight!
    recipe recipes:debug

The ``-U`` argument still suppresses reading of the ``default.cfg`` file from
``BUILDOUT_HOME``::

    >>> print_(system(buildout + ' -U', env=env), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    name base
    op buildout
    op1 b1 1
    op2 b2 2
    op3 b2 3
    op4 b3 4
    op5 b3base 5
    recipe recipes:debug

Log level
---------

We can control the level of logging by specifying a log level in our
configuration file.  For example, to suppress info messages, we can
set the logging level to *WARNING*::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... log-level = WARNING
    ... extends = b1.cfg b2.cfg
    ... """)

    >>> print_(system(buildout), end='')
    name base
    op1 b1 1
    op2 b2 2
    op3 b2 3
    recipe recipes:debug

Socket timeout
--------------

The timeout of the connections to egg and configuration servers can be
configured in the buildout section. Its value is configured in seconds::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... socket-timeout = 5
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = timeout
    ... """)

    >>> print_(system(buildout), end='')
    Setting socket time out to 5 seconds.
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    op timeout
    recipe recipes:debug

If the ``socket-timeout`` is not numeric, a warning is issued and the default
timeout of the Python socket module is used::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... socket-timeout = 5s
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = timeout
    ... """)

    >>> print_(system(buildout), end='')
    Default socket timeout is used !
    Value in configuration is not numeric: [5s].
    <BLANKLINE>
    Develop: '/sample-buildout/recipes'
    Updating debug.
    op timeout
    recipe recipes:debug

Uninstall recipes
-----------------

As we've seen, when parts are installed, buildout keeps track of files
and directories that they create. When the parts are uninstalled these
files and directories are deleted.

Sometimes more clean-up is needed. For example, a recipe might add a
system service by calling ``chkconfig --add`` during installation. Later
during uninstallation, ``chkconfig --del`` will need to be called to
remove the system service.

In order to deal with these uninstallation issues, you can register
uninstall recipes. Uninstall recipes are registered using the
``zc.buildout.uninstall`` entry point. Parts specify uninstall recipes
using the ``uninstall`` option.

In comparison to regular recipes, uninstall recipes are much
simpler. They are simply callable objects that accept the name of the
part to be uninstalled and the part's options dictionary. Uninstall
recipes don't have access to the part itself since it may be
impossible to instantiate at uninstallation time.

Here's a recipe that simulates installation of a system service, along
with an uninstall recipe that simulates removing the service::

    >>> write(sample_buildout, 'recipes', 'service.py',
    ... """
    ... import sys
    ... class Service:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         sys.stdout.write("chkconfig --add %s\\n"
    ...                          % self.options['script'])
    ...         return ()
    ...
    ...     def update(self):
    ...         pass
    ...
    ...
    ... def uninstall_service(name, options):
    ...     sys.stdout.write("chkconfig --del %s\\n" % options['script'])
    ... """)

To use these recipes we must register them using entry points. Make
sure to use the same name for the recipe and uninstall recipe. This is
required to let buildout know which uninstall recipe goes with which
recipe::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... service = service:Service
    ...
    ... [zc.buildout.uninstall]
    ... service = service:uninstall_service
    ... ''')
    ... setup(name="recipes", entry_points=entry_points, py_modules=['debug', 'environ', 'service'])
    ... """)

Here's how these recipes could be used in a buildout::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = service
    ...
    ... [service]
    ... recipe = recipes:service
    ... script = /path/to/script
    ... """)

When the buildout is run the service will be installed::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing service.
    chkconfig --add /path/to/script

The service has been installed. If the buildout is run again with no
changes, the service shouldn't be changed::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Updating service.

Now we change the service part to trigger uninstallation and
re-installation::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = service
    ...
    ... [service]
    ... recipe = recipes:service
    ... script = /path/to/a/different/script
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling service.
    Running uninstall recipe.
    chkconfig --del /path/to/script
    Installing service.
    chkconfig --add /path/to/a/different/script

Now we remove the service part, and add another part::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling service.
    Running uninstall recipe.
    chkconfig --del /path/to/a/different/script
    Installing debug.
    recipe recipes:debug

Uninstall recipes don't have to take care of removing all the files
and directories created by the part. This is still done automatically,
following the execution of the uninstall recipe. An upshot is that an
uninstallation recipe can access files and directories created by a
recipe before they are deleted.

For example, here's an uninstallation recipe that simulates backing up
a directory before it is deleted. It is designed to work with the
``mkdir`` recipe introduced earlier::

    >>> write(sample_buildout, 'recipes', 'backup.py',
    ... """
    ... import os, sys
    ... def backup_directory(name, options):
    ...     path = options['path']
    ...     size = len(os.listdir(path))
    ...     sys.stdout.write("backing up directory %s of size %s\\n"
    ...                      % (path, size))
    ... """)

It must be registered with the ``zc.buildout.uninstall`` entry
point. Notice how it is given the name ``mkdir`` to associate it with
the ``mkdir`` recipe::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... service = service:Service
    ...
    ... [zc.buildout.uninstall]
    ... uninstall_service = service:uninstall_service
    ... mkdir = backup:backup_directory
    ... ''')
    ... setup(name="recipes", entry_points=entry_points, py_modules=['debug', 'environ', 'service', 'backup'])
    ... """)

Now we can use it with a ``mkdir`` part::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = dir debug
    ...
    ... [dir]
    ... recipe = recipes:mkdir
    ... path = my_directory
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

Run the buildout to install the part::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing dir.
    dir: Creating directory my_directory
    Installing debug.
    recipe recipes:debug

Now we remove the part from the configuration file::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

When the buildout is run the part is removed, and the uninstall recipe
is run before the directory is deleted::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling dir.
    Running uninstall recipe.
    backing up directory /sample-buildout/my_directory of size 0
    Updating debug.
    recipe recipes:debug

Now we will return the registration to normal for the benefit of the
rest of the examples::

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... ''')
    ... setup(name="recipes", entry_points=entry_points, py_modules=['debug', 'environ', 'service', 'backup'])
    ... """)


Command-line usage
------------------

A number of arguments can be given on the buildout command line.  The
command usage is::

  buildout [options and assignments] [command [command arguments]]

The following options are supported:

``-h`` (or ``--help``)
    Print basic usage information.  If this option is used, then all
    other options are ignored.

``-c`` filename
    The ``-c`` option can be used to specify a configuration file, rather than
    ``buildout.cfg`` in the current directory.


``-t`` socket_timeout
   Specify the socket timeout in seconds.

``-v``
    Increment the verbosity by 10.  The verbosity is used to adjust
    the logging level.  The verbosity is subtracted from the numeric
    value of the log-level option specified in the configuration file.

``-q``
    Decrement the verbosity by 10.

``-U``
    Don't read user-default configuration.

``-o``
    Run in off-line mode.  This is equivalent to the assignment
    ``buildout:offline=true``.

``-O``
    Run in non-off-line mode.  This is equivalent to the assignment
    ``buildout:offline=false``.  This is the default buildout mode.  The
    ``-O`` option would normally be used to override a true offline
    setting in a configuration file.

``-n``
    Run in newest mode.  This is equivalent to the assignment
    ``buildout:newest=true``.  With this setting, which is the default,
    buildout will try to find the newest versions of distributions
    available that satisfy its requirements.

``-N``
    Run in non-newest mode.  This is equivalent to the assignment
    ``buildout:newest=false``.  With this setting, buildout will not seek
    new distributions if installed distributions satisfy its
    requirements.

Assignments are of the form::

  section_name:option_name=value

or::

  option_name=value

which is equivalent to::

  buildout:option_name=value

Options and assignments can be given in any order.

Here's an example::

    >>> write(sample_buildout, 'other.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... installed = .other.cfg
    ... log-level = WARNING
    ...
    ... [debug]
    ... name = other
    ... recipe = recipes:debug
    ... """)

Note that we used the installed buildout option to specify an
alternate file to store information about installed parts::

    >>> print_(system(buildout+' -c other.cfg debug:op1=foo -v'), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    name other
    op1 foo
    recipe recipes:debug

Here we used the ``-c`` option to specify an alternate configuration file,
and the ``-v`` option to increase the level of logging from the default,
*WARNING*.

Options can also be combined in the usual Unix way, as in::

    >>> print_(system(buildout+' -vcother.cfg debug:op1=foo'), end='')
    Develop: '/sample-buildout/recipes'
    Updating debug.
    name other
    op1 foo
    recipe recipes:debug

Here we combined the ``-v`` and ``-c`` options with the configuration file
name.  Note that the ``-c`` option has to be last, because it takes an
argument::

    >>> os.remove(os.path.join(sample_buildout, 'other.cfg'))
    >>> os.remove(os.path.join(sample_buildout, '.other.cfg'))

The most commonly used command is ``install``, and it takes a list of
parts to install. If any parts are specified, only those parts are
installed.  To illustrate this, we'll update our configuration and run
the buildout in the usual way::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d1 d2 d3
    ...
    ... [d1]
    ... recipe = recipes:mkdir
    ... path = d1
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = d2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = d3
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling debug.
    Installing debug.
    recipe recipes:debug
    Installing d1.
    d1: Creating directory d1
    Installing d2.
    d2: Creating directory d2
    Installing d3.
    d3: Creating directory d3

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  d3
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

    >>> cat(sample_buildout, '.installed.cfg')
    ... # doctest: +NORMALIZE_WHITESPACE
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = debug d1 d2 d3
    <BLANKLINE>
    [debug]
    __buildout_installed__ =
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    recipe = recipes:debug
    <BLANKLINE>
    [d1]
    __buildout_installed__ = /sample-buildout/d1
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d1
    recipe = recipes:mkdir
    <BLANKLINE>
    [d2]
    __buildout_installed__ = /sample-buildout/d2
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = /sample-buildout/d3
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d3
    recipe = recipes:mkdir

Now we'll update our configuration file::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d2 d3 d4
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = data2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = data3
    ...
    ... [d4]
    ... recipe = recipes:mkdir
    ... path = ${d2:path}-extra
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... x = 1
    ... """)

and run the buildout specifying just ``d3`` and ``d4``::

    >>> print_(system(buildout+' install d3 d4'), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling d3.
    Installing d3.
    d3: Creating directory data3
    Installing d4.
    d4: Creating directory data2-extra

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  data2-extra
    d  data3
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

Only the ``d3`` and ``d4`` recipes ran.
``d3`` was removed and ``data3`` and ``data2-extra``
were created.

The ``.installed.cfg`` is only updated for the recipes that ran::

    >>> cat(sample_buildout, '.installed.cfg')
    ... # doctest: +NORMALIZE_WHITESPACE
    [buildout]
    installed_develop_eggs = /sample-buildout/develop-eggs/recipes.egg-link
    parts = debug d1 d2 d3 d4
    <BLANKLINE>
    [debug]
    __buildout_installed__ =
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    recipe = recipes:debug
    <BLANKLINE>
    [d1]
    __buildout_installed__ = /sample-buildout/d1
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d1
    recipe = recipes:mkdir
    <BLANKLINE>
    [d2]
    __buildout_installed__ = /sample-buildout/d2
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = /sample-buildout/data3
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/data3
    recipe = recipes:mkdir
    <BLANKLINE>
    [d4]
    __buildout_installed__ = /sample-buildout/data2-extra
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /sample-buildout/data2-extra
    recipe = recipes:mkdir

Note that the installed data for ``debug``, ``d1``, and ``d2`` haven't
changed,
because we didn't install those parts, and that the ``d1`` and ``d2``
directories are still there.

Now, if we run the buildout without the install command::

    >>> print_(system(buildout), end='')
    Develop: '/sample-buildout/recipes'
    Uninstalling d2.
    Uninstalling d1.
    Uninstalling debug.
    Installing debug.
    recipe recipes:debug
    x 1
    Installing d2.
    d2: Creating directory data2
    Updating d3.
    Updating d4.

We see the output of the debug recipe, and that ``data2`` was created.  We
also see that ``d1`` and ``d2`` have gone away::

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  data2
    d  data2-extra
    d  data3
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

Alternate directory and file locations
--------------------------------------

The buildout normally puts the ``bin``, ``eggs``, and ``parts`` directories in
the directory in the directory containing the configuration file. You can
provide alternate locations, and even names for these directories::

    >>> alt = tmpdir('sample-alt')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... develop-eggs-directory = %(developbasket)s
    ... eggs-directory = %(basket)s
    ... bin-directory = %(scripts)s
    ... parts-directory = %(work)s
    ... """ % dict(
    ...    developbasket = os.path.join(alt, 'developbasket'),
    ...    basket = os.path.join(alt, 'basket'),
    ...    scripts = os.path.join(alt, 'scripts'),
    ...    work = os.path.join(alt, 'work'),
    ... ))

    >>> print_(system(buildout), end='')
    Creating directory '/sample-alt/basket'.
    Creating directory '/sample-alt/scripts'.
    Creating directory '/sample-alt/work'.
    Creating directory '/sample-alt/developbasket'.
    Develop: '/sample-buildout/recipes'
    Uninstalling d4.
    Uninstalling d3.
    Uninstalling d2.
    Uninstalling debug.

    >>> ls(alt)
    d  basket
    d  developbasket
    d  scripts
    d  work

    >>> ls(alt, 'developbasket')
    -  recipes.egg-link

You can also specify an alternate buildout directory::

    >>> rmdir(alt)
    >>> alt = tmpdir('sample-alt')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... directory = %(alt)s
    ... develop = %(recipes)s
    ... parts =
    ... """ % dict(
    ...    alt=alt,
    ...    recipes=os.path.join(sample_buildout, 'recipes'),
    ...    ))

    >>> print_(system(buildout), end='')
    Creating directory '/sample-alt/eggs'.
    Creating directory '/sample-alt/bin'.
    Creating directory '/sample-alt/parts'.
    Creating directory '/sample-alt/develop-eggs'.
    Develop: '/sample-buildout/recipes'

    >>> ls(alt)
    -  .installed.cfg
    d  bin
    d  develop-eggs
    d  eggs
    d  parts

    >>> ls(alt, 'develop-eggs')
    -  recipes.egg-link

Logging control
---------------

Three buildout options are used to control logging:

``log-level``
   specifies the log level

``verbosity``
   adjusts the log level

``log-format``
   allows an alternate logging format to be specified

We've already seen the log level and verbosity.  Let's look at an example
of changing the format::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... log-level = 25
    ... verbosity = 5
    ... log-format = %(levelname)s %(message)s
    ... """)

Here, we've changed the format to include the log-level name, rather
than the logger name.

We've also illustrated, with a contrived example, that the log level
can be a numeric value and that the verbosity can be specified in the
configuration file.  Because the verbosity is subtracted from the log
level, we get a final log level of 20, which is the *INFO* level::

    >>> print_(system(buildout), end='')
    INFO Develop: '/sample-buildout/recipes'

Predefined buildout options
---------------------------

Buildouts have a number of predefined options that recipes can use
and that users can override in their configuration files.  To see
these, we'll run a minimal buildout configuration with a ``debug`` logging
level.  One of the features of ``debug`` logging is that the configuration
database is shown::

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... parts =
    ... """)

    >>> print_(system(buildout+' -vv'), end='') # doctest: +NORMALIZE_WHITESPACE
    Installing 'zc.buildout', 'setuptools', 'pip', 'wheel'.
    ...
    Configuration data:
    [buildout]
    allow-hosts = *
    allow-picked-versions = true
    allow-unknown-extras = false
    bin-directory = /sample-buildout/bin
    develop-eggs-directory = /sample-buildout/develop-eggs
    directory = /sample-buildout
    eggs-directory = /sample-buildout/eggs
    executable = python
    find-links =
    install-from-cache = false
    installed = /sample-buildout/.installed.cfg
    log-format =
    log-level = INFO
    newest = true
    offline = false
    parts =
    parts-directory = /sample-buildout/parts
    prefer-final = true
    python = buildout
    show-picked-versions = false
    socket-timeout =
    update-versions-file =
    use-dependency-links = true
    verbosity = 20
    versions = versions
    [versions]
    zc.buildout = >=1.99
    zc.recipe.egg = >=1.99
    <BLANKLINE>

All of these options can be overridden by configuration files or by
command-line assignments.  We've discussed most of these options
already, but let's review them and touch on some we haven't discussed:

``abi-tag-eggs``
    Add an `ABI tag
    <https://www.python.org/dev/peps/pep-0425/#abi-tag>`_ to the
    directory name given by the ``eggs-directory`` option.  This is
    useful when switching between python implementations when details
    of the implementation aren't reflected in egg names.  It also has
    the side benefit of making eggs directories smaller, because eggs
    for different Python versions are in different directories.

``allow-hosts``
    On some environments the links visited by ``zc.buildout`` can be forbidden
    by paranoid firewalls. These URLs might be in the chain of links visited
    by ``zc.buildout`` as defined by buildout's ``find-links`` option, or as
    defined by various eggs in their ``url``, ``download_url``,
    ``dependency_links`` metadata.

    The fact that ``package_index`` works like a spider and might visit links
    and go to other locations makes this even harder.

    The ``allow-hosts`` option provides a way to prevent this, and
    works exactly like the one provided in ``easy_install``.

    You can provide a list of allowed hosts, together with wildcards::

        [buildout]
        ...

        allow-hosts =
            *.python.org
            example.com

    All URLs that do not match these hosts will not be visited.

``allow-picked-versions``
    By default, the buildout will choose the best match for a given
    requirement
    if the requirement is not specified precisely (for instance, using the
    ``versions`` option.  This behavior corresponds to the
    ``allow-picked-versions`` being set to its default value, ``true``.  If
    ``allow-picked-versions`` is ``false``, instead of picking the best match,
    buildout will raise an error.  This helps enforce repeatability.

``bin-directory``
   The directory path where scripts are written.  This can be a
   relative path, which is interpreted relative to the directory
   option.

``develop-eggs-directory``
   The directory path where development egg links are created for software
   being created in the local project.  This can be a relative path,
   which is interpreted relative to the directory option.

``directory``
   The buildout directory.  This is the base for other buildout file
   and directory locations, when relative locations are used.

``eggs-directory``
   The directory path where downloaded eggs are put.  It is common to share
   this directory across buildouts.
   This can be a relative path, which is
   interpreted relative to the directory option.

   .. warning::

     Eggs in this directory should *never* be modified.

``find-links``
    You can specify more locations to search for distributions using the
    ``find-links`` option. All locations specified will be searched for
    distributions along with the package index as described before.

    Locations can be URLs::

      [buildout]
      ...
      find-links = http://download.zope.org/distribution/

    They can also be directories on disk::

      [buildout]
      ...
      find-links = /some/path

    Finally, they can also be direct paths to distributions::

      [buildout]
      ...
      find-links = /some/path/someegg-1.0.0-py2.3.egg

    Any number of locations can be specified in the ``find-links`` option::

      [buildout]
      ...
      find-links =
          http://download.zope.org/distribution/
          /some/otherpath
          /some/path/someegg-1.0.0-py2.3.egg

``install-from-cache``
    A download cache can be used as the basis of application source releases.
    In an application source release, we want to distribute an application
    that
    can be built without making any network accesses.  In this case, we
    distribute a buildout along with a download cache, and tell the buildout
    to install
    from the download cache only, without making network accesses.  The
    buildout ``install-from-cache`` option can be used to signal that packages
    should be installed only from the download cache.

``installed``
   The file path where information about the results of the previous
   buildout run is written.  This can be a relative path, which is
   interpreted relative to the directory option.  This file provides
   an inventory of installed parts with information needed to decide
   which if any parts need to be uninstalled.

``log-format``
   The format used for logging messages.

``log-level``
   The log level before verbosity adjustment

``newest``
    By default buildout and recipes will try to find the newest versions of
    distributions needed to satisfy requirements.  This can be very time
    consuming, especially when incrementally working on setting up a buildout
    or working on a recipe.  The buildout ``newest`` option can be used to to
    suppress this.  If the ``newest`` option is set to false, then new
    distributions won't be sought if an installed distribution meets
    requirements.  The ``newest`` option can also be set to false using the -N
    command-line option.  See also the ``offline`` option.

``offline``
    The ``offline`` option goes a bit further than the ``newest`` option.
    If the
    buildout ``offline`` option is given a value of ``true``, the buildout and
    recipes that are aware of the option will avoid doing network access.
    This
    is handy when running the buildout when not connected to the internet.  It
    also makes buildouts run much faster. This option is typically set using
    the buildout ``-o`` option.

``parts``
   A whitespace-separated list of parts to be installed.

``parts-directory``
   A working directory that parts can used to store data.

``prefer-final``
    Currently, when searching for new releases, the newest available
    release is used.  This isn't usually ideal, as you may get a
    development release or alpha releases not ready to be widely used.
    You can request that final releases be preferred using the
    ``prefer-final`` option in the ``buildout`` section::

      [buildout]
      ...
      prefer-final = true

    When the ``prefer-final`` option is set to ``true``, then when searching
    for
    new releases, final releases are preferred.  If there are final
    releases that satisfy distribution requirements, then those releases
    are used even if newer non-final releases are available.  The buildout
    ``prefer-final`` option can be used to override this behavior.

    In buildout version 2, final releases will be preferred by default.
    You will then need to use a ``false`` value for ``prefer-final`` to get
    the newest releases.

``use-dependency-links``
    By default buildout will obey the setuptools ``dependency_links`` metadata
    when it looks for dependencies. This behavior can be controlled with
    the ``use-dependency-links`` buildout option::

      [buildout]
      ...
      use-dependency-links = false

    The option defaults to ``true``. If you set it to ``false``, then
    dependency links are only looked for in the locations specified by
    ``find-links``.

``verbosity``
   A log-level adjustment.  Typically, this is set via the ``-q`` and ``-v``
   command-line options.


Creating new buildouts and bootstrapping
----------------------------------------

If ``zc.buildout`` is installed, you can use it to create a new buildout
with its own local copies of ``zc.buildout`` and ``setuptools`` and with
local buildout scripts::

    >>> sample_bootstrapped = tmpdir('sample-bootstrapped')

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped, 'setup.cfg')
    ...              +' init'), end='')
    Creating '/sample-bootstrapped/setup.cfg'.
    Creating directory '/sample-bootstrapped/eggs'.
    Creating directory '/sample-bootstrapped/bin'.
    Creating directory '/sample-bootstrapped/parts'.
    Creating directory '/sample-bootstrapped/develop-eggs'.
    Generated script '/sample-bootstrapped/bin/buildout'.

Note that a basic ``setup.cfg`` was created for us.  This is because we
provided an ``init`` argument.  By default, the generated
``setup.cfg`` is as minimal as can be::

    >>> cat(sample_bootstrapped, 'setup.cfg')
    [buildout]
    parts =

We also get other buildout artifacts::

    >>> ls(sample_bootstrapped)
    d  bin
    d  develop-eggs
    d  eggs
    d  parts
    -  setup.cfg

    >>> ls(sample_bootstrapped, 'bin')
    -  buildout

    >>> _ = (ls(sample_bootstrapped, 'eggs'),
    ...      ls(sample_bootstrapped, 'develop-eggs'))
    -  pip.egg-link
    -  setuptools.egg-link
    -  wheel.egg-link
    -  zc.buildout.egg-link

(We list both the ``eggs`` and ``develop-eggs`` directories because the
buildout or setuptools egg could be installed in the ``develop-eggs``
directory if the original buildout had develop eggs for either
buildout or setuptools.)

Note that the buildout script was installed but not run.  To run
the buildout, we'd have to run the installed buildout script.

If we have an existing buildout that already has a ``buildout.cfg``, we'll
normally use the ``bootstrap`` command instead of ``init``.  It will complain
if there isn't a configuration file::

    >>> sample_bootstrapped2 = tmpdir('sample-bootstrapped2')

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped2, 'setup.cfg')
    ...              +' bootstrap'), end='')
    While:
      Initializing.
    Error: Couldn't open /sample-bootstrapped2/setup.cfg

    >>> write(sample_bootstrapped2, 'setup.cfg',
    ... """
    ... [buildout]
    ... parts =
    ... """)

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped2, 'setup.cfg')
    ...              +' bootstrap'), end='')
    Creating directory '/sample-bootstrapped2/eggs'.
    Creating directory '/sample-bootstrapped2/bin'.
    Creating directory '/sample-bootstrapped2/parts'.
    Creating directory '/sample-bootstrapped2/develop-eggs'.
    Generated script '/sample-bootstrapped2/bin/buildout'.

Similarly, if there is a configuration file and we use the ``init``
command, we'll get an error that the configuration file already
exists::

    >>> print_(system(buildout
    ...              +' -c'+os.path.join(sample_bootstrapped, 'setup.cfg')
    ...              +' init'), end='')
    While:
      Initializing.
    Error: '/sample-bootstrapped/setup.cfg' already exists.

Initial eggs
------------

When using the ``init`` command, you can specify distribution requirements
or paths to use::

    >>> cd(sample_bootstrapped)
    >>> remove('setup.cfg')
    >>> print_(system(buildout + ' -csetup.cfg init demo other ./src'), end='')
    Creating '/sample-bootstrapped/setup.cfg'.
    Creating directory '/sample-bootstrapped/develop-eggs'.
    Getting distribution for 'zc.recipe.egg>=2.0.6'.
    Got zc.recipe.egg
    Installing py.
    Getting distribution for 'demo'.
    Got demo 0.3.
    Getting distribution for 'other'.
    Got other 1.0.
    Getting distribution for 'demoneeded'.
    Got demoneeded 1.1.
    Generated script '/sample-bootstrapped/bin/demo'.
    Generated script '/sample-bootstrapped/bin/distutilsscript'.
    Generated interpreter '/sample-bootstrapped/bin/py'.

This causes a ``py`` part to be included that sets up a custom Python
interpreter with the given requirements or paths::

    >>> cat('setup.cfg')
    [buildout]
    parts = py
    <BLANKLINE>
    [py]
    recipe = zc.recipe.egg
    interpreter = py
    eggs =
      demo
      other
    extra-paths =
      ./src

Passing requirements or paths causes the buildout to be run as part
of initialization.  In the example above, we got a number of
distributions installed and 2 scripts generated.  The first, ``demo``,
was defined by the ``demo`` project. The second, ``py`` was defined by
the generated configuration.  It's a *custom interpreter* that behaves
like a standard Python interpreter, except that it includes the specified
eggs and extra paths in its Python path.

We specified a source directory that didn't exist. Buildout created it
for us::

    >>> ls('.')
    -  .installed.cfg
    d  bin
    d  develop-eggs
    d  eggs
    d  parts
    -  setup.cfg
    d  src

    >>> uncd()

.. Make sure it works if the dir is already there:

    >>> cd(sample_bootstrapped)
    >>> _ = system(buildout + ' -csetup.cfg buildout:parts=')
    >>> remove('setup.cfg')
    >>> print_(system(buildout + ' -csetup.cfg init demo other ./src'), end='')
    Creating '/sample-bootstrapped/setup.cfg'.
    Creating directory '/sample-bootstrapped/develop-eggs'.
    Installing py.
    Generated script '/sample-bootstrapped/bin/demo'.
    Generated script '/sample-bootstrapped/bin/distutilsscript'.
    Generated interpreter '/sample-bootstrapped/bin/py'.

.. cleanup

    >>> _ = system(buildout + ' -csetup.cfg buildout:parts=')
    >>> uncd()

Finding distributions
---------------------

By default, buildout searches the Python Package Index when looking
for distributions. You can, instead, specify your own index to search
using the `index` option::

  [buildout]
  ...
  index = https://index.example.com/

This index, or the default of https://pypi.org/simple/ if no
index is specified, will always be searched for distributions unless
running buildout with options that prevent searching for
distributions. The latest version of the distribution that meets the
requirements of the buildout will always be used.

You can also specify more locations to search for distributions using
the ``find-links`` option. See its description above.

Controlling the installation database
-------------------------------------

The buildout ``installed`` option is used to specify the file used to save
information on installed parts.  This option is initialized to
``.installed.cfg``, but it can be overridden in the configuration file
or on the command line::

    >>> write('buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print_(system(buildout+' buildout:installed=inst.cfg'), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    recipe recipes:debug

    >>> ls(sample_buildout)
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  demo
    d  develop-eggs
    d  eggs
    -  inst.cfg
    d  parts
    d  recipes

The installation database can be disabled by supplying an empty
buildout installed option::

    >>> os.remove('inst.cfg')
    >>> print_(system(buildout+' buildout:installed='), end='')
    Develop: '/sample-buildout/recipes'
    Installing debug.
    recipe recipes:debug

    >>> ls(sample_buildout)
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes


Note that there will be no installation database if there are no parts::

    >>> write('buildout.cfg',
    ... """
    ... [buildout]
    ... parts =
    ... """)

    >>> print_(system(buildout+' buildout:installed=inst.cfg'), end='')

    >>> ls(sample_buildout)
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  demo
    d  develop-eggs
    d  eggs
    d  parts
    d  recipes

Extensions
----------

A feature allows code to be loaded and run *after*
configuration files have been read, but *before* the buildout has begun
any processing.  The intent is to allow special plugins such as
``urllib2`` request handlers to be loaded.

To load an extension we use the ``extensions`` option and list one or
more distribution requirements, on separate lines.  The distributions
named will be loaded and any ``zc.buildout.extension`` entry points found
will be called with the buildout as an argument.  When buildout
finishes processing, any ``zc.buildout.unloadextension`` entry points
found will be called with the buildout as an argument.

Let's create a sample extension in our sample buildout created in the
previous section::

    >>> mkdir(sample_bootstrapped, 'demo')

    >>> write(sample_bootstrapped, 'demo', 'demo.py',
    ... """
    ... import sys
    ... def ext(buildout):
    ...     sys.stdout.write('%s %s\\n' % ('ext', sorted(buildout)))
    ... def unload(buildout):
    ...     sys.stdout.write('%s %s\\n' % ('unload', sorted(buildout)))
    ... """)

    >>> write(sample_bootstrapped, 'demo', 'setup.py',
    ... """
    ... from setuptools import setup
    ...
    ... setup(
    ...     name = "demo",
    ...     entry_points = {
    ...        'zc.buildout.extension': ['ext = demo:ext'],
    ...        'zc.buildout.unloadextension': ['ext = demo:unload'],
    ...        },
    ...     )
    ... """)

Our extension just prints out the word 'demo', and lists the sections
found in the buildout passed to it.

We'll update our ``buildout.cfg`` to list the demo directory as a develop
egg to be built::

    >>> write(sample_bootstrapped, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... parts =
    ... """)

    >>> os.chdir(sample_bootstrapped)
    >>> print_(system(os.path.join(sample_bootstrapped, 'bin', 'buildout')),
    ...        end='')
    Develop: '/sample-bootstrapped/demo'

Now we can add the ``extensions`` option.  We were a bit tricky and ran
the buildout once with the demo develop egg defined but without the
extension option.  This is because extensions are loaded before the
buildout creates develop eggs. We needed to use a separate buildout
run to create the develop egg.  Normally, when eggs are loaded from
the network, we wouldn't need to do anything special. ::

    >>> write(sample_bootstrapped, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = demo
    ... extensions = demo
    ... parts =
    ... """)

We see that our extension is loaded and executed::

    >>> print_(system(os.path.join(sample_bootstrapped, 'bin', 'buildout')),
    ...        end='')
    ext ['buildout', 'versions']
    Develop: '/sample-bootstrapped/demo'
    unload ['buildout', 'versions']

..

    >>> stop_server(server_url)
